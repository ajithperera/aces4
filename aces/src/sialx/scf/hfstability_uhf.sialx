import "hfstability_uhf_defs.sialx"  

# Looks for HF instablities. Both RH (singlet) and UHF (triplet) 
# instabilities are handled. If instablities are found, the
# vectors corresponding to the largest is written out  so that
# another scf can be run starting with those vectors. 
# Ajith Perera, 04/2017.

			SIAL HFSTABILITY_UHF
#                       --------------------

      Index Ndim     = 1: 100
      Index Nroots   = 1: 30
      Index Mroots   = 1: 30
      Index Subsp_dim= 1: 50
      Index Nindex50 = 1: 50
      Index Mindex50 = 1: 50
      Index Kindex50 = 1: 50
      Index Lindex50 = 1: 50
      Index Spn_mult = 1: 2
#
      aoindex mu     = 1: norb
      aoindex nu     = 1: norb
      aoindex lambda = 1: norb
      aoindex sigma  = 1: norb
#
      moaindex i = baocc: eaocc
      moaindex i1= baocc: eaocc
      moaindex i2= baocc: eaocc
      moaindex i3= baocc: eaocc
#
      moaindex a = bavirt: eavirt
      moaindex a1= bavirt: eavirt
      moaindex a2= bavirt: eavirt
      moaindex a3= bavirt: eavirt
#
      mobindex j = bbocc: ebocc
      mobindex j1= bbocc: ebocc
      mobindex j2= bbocc: ebocc
      mobindex j3= bbocc: ebocc
#
      mobindex b = bbvirt: ebvirt
      mobindex b1= bbvirt: ebvirt
      mobindex b2= bbvirt: ebvirt
      mobindex b3= bbvirt: ebvirt
#
      moaindex p = baocc: eavirt
      moaindex p1= baocc: eavirt
      moaindex p2= baocc: eavirt
      moaindex p3= baocc: eavirt
#
      mobindex q = bbocc: ebvirt
      mobindex q1= bbocc: ebvirt
      mobindex q2= bbocc: ebvirt
      mobindex q3= bbocc: ebvirt

      Distributed Vxxjj[mu,nu,j1,j]
      Distributed Vjjxx[j1,nu,lambda,j]
      Distributed Vjxxj[j1,nu,lambda,j]
      Distributed Vxjqj[mu,j,q,j1]
      Distributed Vjxbj[j,mu,b,j1]
      Distributed Vxbjj[mu,b,j,j1]     
      Distributed Vxbii[mu,b,i,i1]  
      Distributed Vxixi[mu,i1,lambda,i]
      Distributed Vxxii[mu,nu,i1,i]
      Distributed Viixx[i1,i,mu,nu]
      Distributed Vixxi[i1,nu,lambda,i]
      Distributed Vixai[i,mu,a,i1]
      Distributed Vxaii[mu,a,i,i1]   
      Distributed Vixbj[i,mu,b,j] 
      Distributed Vixxj[i,mu,nu,j] 
      Distributed Vxjxj[mu,j1,lambda,j]
      Distributed Vxixj[mu,i,lambda,j]
      Distributed Vxipi[mu,i,p,i1]
      Distributed Vxiqj[mu,i,q,j] 

      Distributed VSpipi[p1,i,p,i1]
      Distributed Viaai[i,a1,a,i1]
      Distributed Vaaii[a,a1,i,i1]
      Distributed VSaaai[a2,a,a1,i]
      Distributed VSqjqj[q1,j,q,j1]
      Distributed Vjbbj[j,b1,b,j1]
      Distributed Vbbjj[b,b1,j,j1]
      Distributed VSbbbj[b2,b,b1,j]
      Distributed Vpiqj[p,i,q,j]
      Distributed Vaajj[a,a1,j,j1]
      Distributed Viabj[i,a,b,j]
      Distributed Vaabj[a,a1,b,j]
      Distributed Vjbii[j,b,i,i1]
      Distributed Vbbii[b,b1,i,i1]
      Distributed Vbbai[b,b1,a,i]
      Distributed Vaaai[a,a1,a2,i]

#
      local lai[a,i]
      local lia[i,a]
      local ljb[j,b]
      local l2ai[a,i]
      local laa[a,a1]
      local lbb[b,b1]
      local lii[i1,i]
      local ljj[j1,j]
      local lbj[b,j]
#
# Distributed arrays 
#
      distributed DDaa[a,a1]
      distributed DDii[i,i1]
      distributed DDia[i,a]
      distributed DDbb[b,b1]
      distributed DDjj[j,j1]
      distributed DDjb[j,b]
      distributed Fae_a[a,a1]
      distributed Fae_b[b,b1]
      distributed Fmi_a[i1,i]
      distributed Fmi_b[j1,j]
      distributed Fia_a[i,a]
      distributed Fia_b[j,b]
#
      DISTRIBUTED R1A[a,i]
      DISTRIBUTED R1B[b,j]
      DISTRIBUTED R1A_INTMD[a,i]
      DISTRIBUTED R1B_INTMD[b,j]
      DISTRIBUTED HR1A[a,i]
      DISTRIBUTED HR1B[b,j]
      DISTRIBUTED R1A_HIST[a,i,NINDEX50]
      DISTRIBUTED R1B_HIST[b,j,NINDEX50]
      DISTRIBUTED HR1A_HIST[a,i,NINDEX50]
      DISTRIBUTED HR1B_HIST[b,j,NINDEX50]
      DISTRIBUTED R1DA[a,i]
      DISTRIBUTED R1DB[b,j]
      DISTRIBUTED RES1A[a,i]
      DISTRIBUTED RES1B[b,j]
      DISTRIBUTED CORR_VECa[a,i]
      DISTRIBUTED CORR_VECb[b,j]
      DISTRIBUTED Y1a[a,i,NINDEX50]
      DISTRIBUTED Y1b[b,j,NINDEX50]
      DISTRIBUTED Y1a_PICKED[a,i]
      DISTRIBUTED Y1b_PICKED[b,j]
      DISTRIBUTED HY1a_PICKED[a,i]
      DISTRIBUTED HY1b_PICKED[b,j]
      DISTRIBUTED ORTHO_COEF[NINDEX50,MINDEX50]
      
      static Sii[i,i1]
      static Sdii[i,i1]
      static Saa[a,a1]
      static Sdaa[a,a1]
      static Sia[i,a]
      static Sdia[i,a]
      static Sjj[j,j1]
      static Sdjj[j,j1]
      static Sbb[b,b1]
      static Sdbb[b,b1]
      static A_MATRIX[MINDEX50,NINDEX50]
      static DVECTORS[MINDEX50,NINDEX50]
      static DUMMY[MINDEX50,NINDEX50]
      static OVERLAP_R[MINDEX50]
      static A_DIAGS[MINDEX50]
      Static RPA_S_EES[MROOTS]
      Static RPA_T_EES[MROOTS]
      Static RVEC_AA_INTMD[a,i,NROOTS]
      Static RVEC_BB_INTMD[b,j,NROOTS]
      Static DIAGA[a,i]
      Static DIAGB[b,j]
      Static INIT_RVEC_AA[a,i,NROOTS]
      Static INIT_RVEC_BB[b,j,NROOTS]
      Static ETEMP[KINDEX50,LINDEX50]
#      Static ORTHO_COEF[NINDEX50,MINDEX50]
      Static SR1DA[a,i]
      Static SR1DB[b,j]
#
#      Int TARGET_ROOTS
#      Int MAX_SUBSP_DIM

      Scalar TARGET_ROOTS
      Scalar MAX_SUBSP_DIM
      Scalar ROOT_COUNT
      Scalar EOM_THRES
      Scalar MYROOT
      Scalar COUNTER
      Scalar tmp
      Scalar tmpa
      Scalar tmpb
      Scalar suma
      Scalar sumb
      Scalar sumab
      Scalar Sumaaa
      Scalar Sumbbb
      Scalar Sumaab
      Scalar Sumbba
      Scalar Iter_count
      Scalar Count
      Scalar Ncount
      Scalar Mcount
      Scalar Kcount
      Scalar Lcount
      Scalar HC_A
      Scalar HC_B
      Scalar SUM_R
      Scalar C_A
      Scalar C_B
      Scalar A_VALUE
      Scalar CY_A
      Scalar CY_B
      Scalar CY_AB
      Scalar IMAX
      Scalar Omega
      Scalar Omegam
      Scalar Eig_value
      Scalar NORM_PREV_C
      Scalar NORM_FAC 
      Scalar FACT
      Scalar INV_SQRT_NORM_ORTGC
      Scalar NORM_NEW_ORTGC
      Scalar INV_SQRT_NORM_R
      Scalar NORM_R
      Scalar NORM_GHG
      Scalar NORM_OF_CORRECTION
      Scalar RANK
      Scalar RESIDUAL_NORM
      Scalar SQRT_OVERLAP
      Scalar OMEGA0
      Scalar OMEGA0M
      Scalar HALF
      Scalar PRINT_FLAG
      Scalar RPA_THRES 
      Scalar ONE
      Scalar MONE
      Scalar ZERO
      Scalar TWO
      Scalar Singlet 
      Scalar Triplet 
      Scalar MUlt 
      Scalar Five_five
      Scalar Five_six
      Scalar IMEM_MAX
      Scalar ZMEM_MAX
      Scalar REORD_FLAG
      Scalar AA
      Scalar BB
#
      temp TS[MINDEX50,NINDEX50]
      temp daoint[mu,nu,lambda,sigma] 
      temp Txixi[mu,i1,lambda,i]
      temp T1xixi[mu,i1,lambda,i]
      temp Txxii[mu,nu,i1,i]
      temp Tixxi[i1,nu,lambda,i]
      temp Txipi[mu,i,p,i1]
      temp Tpipi[p1,i,p,i1]
      temp T1pipi[p1,i,p,i1]
      temp T2pipi[p1,i,p,i1]
      temp Tixai[i,mu,a,i1]
      temp Txaii[mu,a,i,i1]
      temp T1xjqj[mu,j,q,j1]
#
      temp Txxxi[mu,nu,sigma,i]
      temp T1xxxi[mu,nu,sigma,i]
      temp Txxxj[mu,nu,sigma,j]
      temp T1xxxj[mu,nu,sigma,j]
#
      temp Txjxj[mu,j1,lambda,j]
      temp T1xjxj[mu,j1,lambda,j]
      temp Txxjj[mu,nu,j1,j]
      temp Tjjxx[j1,nu,lambda,j]
      temp Tjxxj[j1,nu,lambda,j]
      temp T1xipi[mu,i,p,i1]
      temp T1xiqj[mu,i,q,j]
      temp Txjqj[mu,j,q,j1]
      temp Tqjqj[q1,j,q,j1]
      temp T1qjqj[q1,j,q,j1]
      temp T2qjqj[q1,j,q,j1]
      temp Tjxbj[j,mu,b,j1]
      temp Txbjj[mu,b,j,j1]
      temp Txbbj[mu,b1,b,j]
      temp Tbbbj[b2,b,b1,j]
      temp T1bbbj[b2,b,b1,j]
      temp Txxbj[mu,nu,b,j]
      temp txixx[lambda,i,mu,nu]
      temp t1xixx[lambda,i,mu,nu]
      temp t2xixx[lambda,i,mu,nu]
      temp t3xixx[lambda,i,mu,nu]
      temp txjxx[lambda,j,mu,nu]
      temp t1xjxx[lambda,j,mu,nu]
      temp t2xjxx[lambda,j,mu,nu]
      temp t3xjxx[lambda,j,mu,nu]
      temp txxix[nu,mu,i,lambda]
      temp t1xxix[nu,mu,i,lambda]
      temp t2xxix[nu,mu,i,lambda]
      temp t3xxix[nu,mu,i,lambda]
      temp txxjx[nu,mu,j,lambda]
      temp t1xxjx[nu,mu,j,lambda]
      temp t2xxjx[nu,mu,j,lambda]
      temp t3xxjx[nu,mu,j,lambda]
#
      temp Txixj[mu,i,nu,j]
      temp Txiqj[mu,i,q,j]
      temp Tpiqj[p,i,q,j]
      temp T1piqj[p,i,q,j]
      temp T2piqj[p,i,q,j]
      temp Tiixx[i,i1,mu,nu]
      temp Tiixb[i,i1,mu,b]
      temp Tiibb[i,i1,b1,b]
      temp Txajj[mu,a,j,j1]
      temp Taajj[a,a1,j,j1]
      temp Txabj[mu,a,b,j]
      temp Tixxj[i,mu,nu,j]
      temp Tixbj[i,mu,b,j]
      temp Taabj[a,a1,b,j] 
      temp Txbii[mu,b,i,i1]
      temp Tbbii[b,b1,i,i1]
      temp Tjbii[j,b,i,i1]
      temp Txbai[mu,b,a,i]
      temp Tbbai[b,b1,a,i]

      temp T1aix[a,i,NINDEX50]
      temp T1bjx[b,j,NINDEX50]
      temp TXX[MINDEX50,MINDEX50]
#
      temp  Tiaai[i1,a1,a,i]
      temp  TSiaai[i,a,a1,i1]
      temp  TS2iaai[i,a,a1,i1]
      temp  TSbjbj[b,j,b1,j1]
      temp  Taaii[a,a2,i,i2]
      temp  T1aaii[a,a2,i,i2]
      temp  Tbbjj[b,b1,j,j1]
      temp  T2bbjj[b,b1,j,j1]
      temp  Tii[i,i1]
      temp  T1ii[i,i1]
      temp  T1jj[j,j1]
      temp  Tjj[j,j1]
      temp  Taa[a,a1]
      temp  Tbb[b,b1]
      temp  tai[a,i]
      temp  t1ai[a,i]
      temp  t2ai[a,i]
      temp  t11ai[a,i]
      temp  t1aa[a,a1]
      temp  t11aa[a,a1]
      temp  t1bb[b,b1]
      temp  t11bb[b,b1]
      temp  t111bb[b,b1]
      temp  tia[i,a]
      temp  t2ia[i,a]
      temp  t2jb[j,b]
      temp  t1ia[i,a]
      temp  t3ai[a,i]
      temp  tbj[b,j]
      temp  tjb[j,b]
      temp  t1jb[j,b]
      temp  t1bj[b,j]
      temp  t2bj[b,j]
      temp  t3bj[b,j]
      temp  t11bj[b,j]
      temp  Tjbbj[j1,b1,b,j]
      temp  Tiabj[i,a,b,j]
      temp  Taix[a,i,MINDEX50]
      temp  Tbjx[b,j,MINDEX50]
      temp  T2aix[a,i,NROOTS]
      temp  T2bjx[b,j,NROOTS]
#
      local L0xxxi[mu,nu,lambda,i]
      local L1xxxi[nu,mu,lambda,i]
      local L2xxxi[mu,nu,sigma,i]
      local L3xxxi[nu,mu,sigma,i]
#
      local L0xxxj[mu,nu,lambda,j]
      local L1xxxj[nu,mu,lambda,j]
      local L2xxxj[mu,nu,sigma,j]
      local L3xxxj[nu,mu,sigma,j]
#
      temp V0xxxi[mu,nu,lambda,i]
      temp V0xxxj[mu,nu,lambda,j]
#
      local Lxixi[mu,i1,lambda,i]
      local Lxixj[mu,i,lambda,j]
      local Lxjxj[mu,j1,lambda,j]
      local Lxxii[mu,nu,i1,i]
      local Lxxjj[mu,nu,j1,j]
      local Lixxi[i1,nu,lambda,i]
      local Lixxj[i,nu,lambda,j]
      local Ljxxj[j1,nu,lambda,j]
      local Lxipi[mu,i,p,i1]
      local Lpipi[p1,i,p,i1]
      local Lxaii[mu,a,i,i1]
      local Laaii[a1,a,i,i1]
      local Lixai[i,mu,a,i1]
      local Liaai[i,a1,a,i1]
#
      local Lxjqj[mu,j,q,j1]
      local Lqjqj[q1,j,q,j1]
      local Lxbjj[mu,b,j,j1]
      local Lbbjj[b1,b,j,j1]
      local Ljxbj[j,mu,b,j1]
      local Ljbbj[j,b1,b,j1]
      local Lxbii[mu,b,i,i1]
      local Lbbii[b1,b,i,i1]
      local Lxajj[mu,a,j,j1]
      local Laajj[a1,a,j,j1]
      local Lixbj[i,mu,b,j]
      local Liabj[i,a,b,j]
      local Liixb[i,i1,mu,b]
      local Liibb[i,i1,b1,b]
      local Lxiqj[mu,i,q,j]
      local Lpiqj[p,i,q,j]
#
      local Lxiai[mu,i,a1,i1]
      local Lxjbj[mu,j,b1,j1]
      local Lxibj[mu,i,b,j]
      local L1xixi[mu,i,nu,i1]
      local L1xjxj[mu,j,nu,j1]
      local L1xixj[mu,i,nu,j]
#
     PROC TRAN_XXII
#    --------------
#
      sip_barrier
#
      PARDO mu, nu, lambda
        WHERE mu < nu 
            allocate L0xxxi[mu,nu,lambda,*] 
            allocate L0xxxj[mu,nu,lambda,*] 
            DO  sigma
#
                execute compute_integral_batch daoint[mu,nu,lambda,sigma]
#
                DO i
                   txxxi[mu,nu,lambda,i]  = daoint[mu,nu,lambda,sigma]*ca[sigma,i]
                   L0xxxi[mu,nu,lambda,i] += txxxi[mu,nu,lambda,i]
                ENDDO i
#
                DO j
                   txxxj[mu,nu,lambda,j]  = daoint[mu,nu,lambda,sigma]*cb[sigma,j]
                   L0xxxj[mu,nu,lambda,j] += txxxj[mu,nu,lambda,j]
                ENDDO j
#
           ENDDO  sigma
#     
           DO i
#     
              txixx[lambda,i,mu,nu] = L0xxxi[mu,nu,lambda,i]
              txxix[nu,mu,i,lambda] = L0xxxi[mu,nu,lambda,i]
#
              DO i1
                 Txxii[nu,mu,i,i1]  = txxix[nu,mu,i,lambda]*ca[lambda,i1]
                 PUT Vxxii[nu,mu,i,i1] += Txxii[nu,mu,i,i1]
              ENDDO i1
#
              DO i1
                 Tixxi[i1,nu,lambda,i]  = L0xxxi[mu,nu,lambda,i]*ca[mu,i1]
                 PUT Vixxi[i1,nu,lambda,i] += Tixxi[i1,nu,lambda,i]
              ENDDO i1

              DO i1
                 Txixi[mu,i1,lambda,i]  = L0xxxi[mu,nu,lambda,i]*ca[nu,i1]
                 PUT Vxixi[mu,i1,lambda,i] += Txixi[mu,i1,lambda,i]
              ENDDO i1
#
           ENDDO i
#
           DO j
#     
              txjxx[lambda,j,mu,nu] = L0xxxj[mu,nu,lambda,j]
              txxjx[nu,mu,j,lambda] = L0xxxj[mu,nu,lambda,j]
#
              DO j1
                 Txxjj[nu,mu,j,j1]  = txxjx[nu,mu,j,lambda]*cb[lambda,j1]
                 PUT Vxxjj[nu,mu,j,j1] += Txxjj[nu,mu,j,j1]
              ENDDO j1
#
              DO j1
                 Tjxxj[j1,nu,lambda,j]  = L0xxxj[mu,nu,lambda,j]*cb[mu,j1]
                 PUT Vjxxj[j1,nu,lambda,j] += Tjxxj[j1,nu,lambda,j]
              ENDDO j1

              DO j1
                 Txjxj[mu,j1,lambda,j]  = L0xxxj[mu,nu,lambda,j]*cb[nu,j1]
                 PUT Vxjxj[mu,j1,lambda,j] += Txjxj[mu,j1,lambda,j]
              ENDDO j1
#
              DO i1
                 Tixxj[i1,nu,lambda,j]  = L0xxxj[mu,nu,lambda,j]*ca[mu,i1]
                 PUT Vixxj[i1,nu,lambda,j] += Tixxj[i1,nu,lambda,j]
              ENDDO i1

              DO i
                 Txixj[mu,i,lambda,j]  = L0xxxj[mu,nu,lambda,j]*ca[nu,i]
                 PUT Vxixj[mu,i,lambda,j] += Txixj[mu,i,lambda,j]
              ENDDO i
#
           ENDDO j
#
        deallocate L0xxxi[mu,nu,lambda,*]
        deallocate L0xxxj[mu,nu,lambda,*]

      ENDPARDO mu, nu, lambda 
#
      PARDO mu, nu, lambda
        WHERE mu > nu 
            allocate L0xxxi[mu,nu,lambda,*] 
            allocate L0xxxj[mu,nu,lambda,*] 
            DO  sigma
#
                execute compute_integral_batch daoint[mu,nu,lambda,sigma]
#
                DO i
                   txxxi[mu,nu,lambda,i]  = daoint[mu,nu,lambda,sigma]*ca[sigma,i]
                   L0xxxi[mu,nu,lambda,i] += txxxi[mu,nu,lambda,i]
                ENDDO i
#
                DO j
                   txxxj[mu,nu,lambda,j]  = daoint[mu,nu,lambda,sigma]*cb[sigma,j]
                   L0xxxj[mu,nu,lambda,j] += txxxj[mu,nu,lambda,j]
                ENDDO j
#
           ENDDO  sigma
#     
           DO i
#     
              txixx[lambda,i,mu,nu] = L0xxxi[mu,nu,lambda,i]
              txxix[nu,mu,i,lambda] = L0xxxi[mu,nu,lambda,i]
#
              DO i1
                 Txxii[nu,mu,i,i1]  = txxix[nu,mu,i,lambda]*ca[lambda,i1]
                 PUT Vxxii[nu,mu,i,i1] += Txxii[nu,mu,i,i1]
              ENDDO i1
#
              DO i1
                 Tixxi[i1,nu,lambda,i]  = L0xxxi[mu,nu,lambda,i]*ca[mu,i1]
                 PUT Vixxi[i1,nu,lambda,i] += Tixxi[i1,nu,lambda,i]
              ENDDO i1

              DO i1
                 Txixi[mu,i1,lambda,i]  = L0xxxi[mu,nu,lambda,i]*ca[nu,i1]
                 PUT Vxixi[mu,i1,lambda,i] += Txixi[mu,i1,lambda,i]
              ENDDO i1
#
           ENDDO i
#
           DO j
#     
              txjxx[lambda,j,mu,nu] = L0xxxj[mu,nu,lambda,j]
              txxjx[nu,mu,j,lambda] = L0xxxj[mu,nu,lambda,j]
#
              DO j1
                 Txxjj[nu,mu,j,j1]  = txxjx[nu,mu,j,lambda]*cb[lambda,j1]
                 PUT Vxxjj[nu,mu,j,j1] += Txxjj[nu,mu,j,j1]
              ENDDO j1

              DO j1
                 Txjxj[mu,j1,lambda,j]  = L0xxxj[mu,nu,lambda,j]*cb[nu,j1]
                 PUT Vxjxj[mu,j1,lambda,j] += Txjxj[mu,j1,lambda,j]
              ENDDO j1
#
              DO j1
                 Tjxxj[j1,nu,lambda,j]  = L0xxxj[mu,nu,lambda,j]*cb[mu,j1]
                 PUT Vjxxj[j1,nu,lambda,j] += Tjxxj[j1,nu,lambda,j]
              ENDDO j1
#
              DO i1
                 Tixxj[i1,nu,lambda,j]  = L0xxxj[mu,nu,lambda,j]*ca[mu,i1]
                 PUT Vixxj[i1,nu,lambda,j] += Tixxj[i1,nu,lambda,j]
              ENDDO i1

              DO i
                 Txixj[mu,i,lambda,j]  = L0xxxj[mu,nu,lambda,j]*ca[nu,i]
                 PUT Vxixj[mu,i,lambda,j] += Txixj[mu,i,lambda,j]
              ENDDO i
#
           ENDDO j
#
        deallocate L0xxxi[mu,nu,lambda,*]
        deallocate L0xxxj[mu,nu,lambda,*]

      ENDPARDO mu, nu, lambda 
#
      PARDO mu, nu, lambda

        WHERE mu == nu 
            allocate L0xxxi[mu,nu,lambda,*] 
            allocate L0xxxj[mu,nu,lambda,*] 
            DO  sigma
#
                execute compute_integral_batch daoint[mu,nu,lambda,sigma]
#
                DO i
                   txxxi[mu,nu,lambda,i]  = daoint[mu,nu,lambda,sigma]*ca[sigma,i]
                   L0xxxi[mu,nu,lambda,i] += txxxi[mu,nu,lambda,i]
                ENDDO i
#
                DO j
                   txxxj[mu,nu,lambda,j]  = daoint[mu,nu,lambda,sigma]*cb[sigma,j]
                   L0xxxj[mu,nu,lambda,j] += txxxj[mu,nu,lambda,j]
                ENDDO j
#
           ENDDO  sigma
#     
           DO i
#     
              txixx[lambda,i,mu,nu] = L0xxxi[mu,nu,lambda,i]
              txxix[nu,mu,i,lambda] = L0xxxi[mu,nu,lambda,i]
#
              DO i1
                 Txxii[nu,mu,i,i1]  = txxix[nu,mu,i,lambda]*ca[lambda,i1]
                 PUT Vxxii[nu,mu,i,i1] += Txxii[nu,mu,i,i1]
              ENDDO i1
#
              DO i1
                 Tixxi[i1,nu,lambda,i]  = L0xxxi[mu,nu,lambda,i]*ca[mu,i1]
                 PUT Vixxi[i1,nu,lambda,i] += Tixxi[i1,nu,lambda,i]
              ENDDO i1

              DO i1
                 Txixi[mu,i1,lambda,i]  = L0xxxi[mu,nu,lambda,i]*ca[nu,i1]
                 PUT Vxixi[mu,i1,lambda,i] += Txixi[mu,i1,lambda,i]
              ENDDO i1
#
           ENDDO i
#
           DO j
#     
              txjxx[lambda,j,mu,nu] = L0xxxj[mu,nu,lambda,j]
              txxjx[nu,mu,j,lambda] = L0xxxj[mu,nu,lambda,j]
#
              DO j1
                 Txxjj[nu,mu,j,j1]  = txxjx[nu,mu,j,lambda]*cb[lambda,j1]
                 PUT Vxxjj[nu,mu,j,j1] += Txxjj[nu,mu,j,j1]
              ENDDO j1
#
              DO j1
                 Tjxxj[j1,nu,lambda,j]  = L0xxxj[mu,nu,lambda,j]*cb[mu,j1]
                 PUT Vjxxj[j1,nu,lambda,j] += Tjxxj[j1,nu,lambda,j]
              ENDDO j1

              DO j1
                 Txjxj[mu,j1,lambda,j]  = L0xxxj[mu,nu,lambda,j]*cb[nu,j1]
                 PUT Vxjxj[mu,j1,lambda,j] += Txjxj[mu,j1,lambda,j]
              ENDDO j1
#
              DO i1
                 Tixxj[i1,nu,lambda,j]  = L0xxxj[mu,nu,lambda,j]*ca[mu,i1]
                 PUT Vixxj[i1,nu,lambda,j] += Tixxj[i1,nu,lambda,j]
              ENDDO i1

              DO i
                 Txixj[mu,i,lambda,j]  = L0xxxj[mu,nu,lambda,j]*ca[nu,i]
                 PUT Vxixj[mu,i,lambda,j] += Txixj[mu,i,lambda,j]
              ENDDO i
#
           ENDDO j
#
        deallocate L0xxxi[mu,nu,lambda,*]
        deallocate L0xxxj[mu,nu,lambda,*]
      ENDPARDO mu, nu, lambda 
#
     sip_barrier
#
     ENDPROC TRAN_XXII
#    -----------------
#
     PROC TRAN_AAII
#    --------------
#
     sip_barrier 
#
     PARDO mu, i, i1
#
           allocate Lxaii[mu,*,i,i1] 
           allocate Lxixi[mu,i,*,i1]
#
           DO nu 
#
              GET Vxxii[mu,nu,i,i1] 
              GET Vxixi[mu,i,nu,i1] 
              Lxixi[mu,i,nu,i1] = Vxixi[mu,i,nu,i1]
#
              DO a
                 Txaii[mu,a,i,i1]  = Vxxii[mu,nu,i,i1]*ca[nu,a]
                 Lxaii[mu,a,i,i1] += Txaii[mu,a,i,i1]
              ENDDO a
#
           ENDDO nu 

           DO a 
#
              PUT Vxaii[mu,a,i,i1] = Lxaii[mu,a,i,i1] 
#
           ENDDO a 

           DO p
#
              Txipi[mu,i,p,i1] = 0.0
#
              DO nu
#
                 T1xipi[mu,i,p,i1] = Lxixi[mu,i,nu,i1]*ca[nu,p]
                 Txipi[mu,i,p,i1] += T1xipi[mu,i,p,i1]
#
              ENDDO nu
#
              PUT Vxipi[mu,i,p,i1] = Txipi[mu,i,p,i1]
#
           ENDDO p

           deallocate Lxaii[mu,*,i,i1] 
           deallocate Lxixi[mu,i,*,i1]
#
     ENDPARDO mu, i, i1
#
     sip_barrier
#
     PARDO a, i, i1
#
           allocate Laaii[*,a,i,i1] 
#
           DO mu 
#
              GET Vxaii[mu,a,i,i1] 
#
              DO a1
#
                 Taaii[a1,a,i,i1]  = Vxaii[mu,a,i,i1]*ca[mu,a1]
                 Laaii[a1,a,i,i1] += Taaii[a1,a,i,i1]
#
              ENDDO a1
#
           ENDDO mu 

           DO a1 
#
              PUT Vaaii[a1,a,i,i1] = Laaii[a1,a,i,i1] 
#
           ENDDO a1 

           deallocate Laaii[*,a,i,i1] 

     ENDPARDO a, i, i1

    PARDO p, i, i1
#
           allocate Lxipi[*,i,p,i1]
#
           DO mu
#
              GET Vxipi[mu,i,p,i1] 
              GET Vxipi[mu,i1,p,i] 

              Lxipi[mu,i,p,i1]  = Vxipi[mu,i,p,i1]
              Txipi[mu,i,p,i1]  = Vxipi[mu,i1,p,i]
              Lxipi[mu,i,p,i1] -= Txipi[mu,i,p,i1]
#
           ENDDO mu 
#
           DO p1
#
              Tpipi[p1,i,p,i1] = 0.0
#
              DO mu 
#
                 T1pipi[p1,i,p,i1] = Lxipi[mu,i,p,i1]*ca[mu,p1]
                 Tpipi[p1,i,p,i1] += T1pipi[p1,i,p,i1]
#
              ENDDO mu
#
              PUT VSpipi[p1,i,p,i1] = Tpipi[p1,i,p,i1]
#
           ENDDO p1
#
           deallocate Lxipi[*,i,p,i1]
#
     ENDPARDO p, i, i1
#
     sip_barrier 

     ENDPROC TRAN_AAII
#    -----------------

     PROC TRAN_IAAI
#    --------------
#
     sip_barrier 
#
     PARDO mu, i, i1
#
           allocate Lixai[i,mu,*,i1] 
#
           DO nu 
#
              GET Vixxi[i,mu,nu,i1] 
#
              DO a
#
                 Tixai[i,mu,a,i1]  = Vixxi[i,mu,nu,i1]*ca[nu,a]
                 Lixai[i,mu,a,i1] += Tixai[i,mu,a,i1]
#
              ENDDO a
#
           ENDDO nu 
#
           DO a 
#
              PUT Vixai[i,mu,a,i1] = Lixai[i,mu,a,i1]
#
           ENDDO a 
#
           deallocate Lixai[i,mu,*,i1] 
#
     ENDPARDO mu, i, i1
#
     sip_barrier 
#
     PARDO a, i, i1
#
           allocate Liaai[i,*,a,i1] 
#
           DO mu 
#
              GET Vixai[i,mu,a,i1] 
#
              DO a1
#
                 Tiaai[i,a1,a,i1]  = Vixai[i,mu,a,i1]*ca[mu,a1]
                 Liaai[i,a1,a,i1] += Tiaai[i,a1,a,i1]
#
              ENDDO a1
#
           ENDDO mu 
#
           DO a1 
#
              GET                    Vaaii[a,a1,i,i1] 
              tiaai[i,a1,a,i1]         = Vaaii[a,a1,i,i1] 
              tiaai[i,a1,a,i1]        -= Liaai[i,a1,a,i1]  
              tiaai[i,a1,a,i1]        *= -1.0  
              PUT Viaai[i,a1,a,i1] = tiaai[i,a1,a,i1]
#
           ENDDO a1 
#
           deallocate Liaai[i,*,a,i1] 
#
     ENDPARDO a, i, i1
#
     sip_barrier 
#
     ENDPROC TRAN_IAAI
#    -----------------
#
     PROC TRAN_BBJJ
#    --------------
#
     sip_barrier 
#
     PARDO mu, j, j1
#
           allocate Lxbjj[mu,*,j,j1] 
           allocate Lxjxj[mu,j,*,j1]
#
           DO nu 
#
              GET Vxxjj[mu,nu,j,j1] 
              GET Vxjxj[mu,j,nu,j1] 
              Lxjxj[mu,j,nu,j1] = Vxjxj[mu,j,nu,j1]
#
              DO b
#
                 Txbjj[mu,b,j,j1]  = Vxxjj[mu,nu,j,j1]*cb[nu,b]
                 Lxbjj[mu,b,j,j1] += Txbjj[mu,b,j,j1]
#
              ENDDO b
#
           ENDDO nu 
#
           DO b 
#
              PUT Vxbjj[mu,b,j,j1] = Lxbjj[mu,b,j,j1]
#
           ENDDO b 
#
           DO q
#
              Txjqj[mu,j,q,j1] = 0.0
#
              DO nu
#
                 T1xjqj[mu,j,q,j1] = Lxjxj[mu,j,nu,j1]*cb[nu,q]
                 Txjqj[mu,j,q,j1] += T1xjqj[mu,j,q,j1]
#
              ENDDO nu
#
              PUT Vxjqj[mu,j,q,j1] = Txjqj[mu,j,q,j1]
#
           ENDDO q
#
           deallocate Lxbjj[mu,*,j,j1] 
           deallocate Lxjxj[mu,j,*,j1] 
#
     ENDPARDO mu, j, j1
#
     sip_barrier
#
     PARDO b, j, j1
#
           allocate Lbbjj[*,b,j,j1]
#
           DO mu
#
              GET Vxbjj[mu,b,j,j1] 
#
              DO b1
#
                 Tbbjj[b1,b,j,j1]  = Vxbjj[mu,b,j,j1]*cb[mu,b1]
                 Lbbjj[b1,b,j,j1] += Tbbjj[b1,b,j,j1]
#
              ENDDO b1
#
           ENDDO mu
#
           DO b1
#
              PUT Vbbjj[b1,b,j,j1] = Lbbjj[b1,b,j,j1]
#
           ENDDO b1
#
           deallocate Lbbjj[*,b,j,j1]
#
     ENDPARDO b, j, j1

     PARDO q, j, j1
#
           allocate Lxjqj[*,j,q,j1]
#
           DO mu

              GET Vxjqj[mu,j,q,j1]
              GET Vxjqj[mu,j1,q,j]
              Lxjqj[mu,j,q,j1]  = Vxjqj[mu,j,q,j1]
              Txjqj[mu,j,q,j1]  = Vxjqj[mu,j1,q,j]
              Lxjqj[mu,j,q,j1] -= Txjqj[mu,j,q,j1]

           ENDDO mu

           DO q1
#
              Tqjqj[q1,j,q,j1] = 0.0
#
              DO mu
#
                 T1qjqj[q1,j,q,j1]      = Lxjqj[mu,j,q,j1]*cb[mu,q1]
                 Tqjqj[q1,j,q,j1]      += T1qjqj[q1,j,q,j1]
#
              ENDDO mu
#
              pUT VSqjqj[q1,j,q,j1] = Tqjqj[q1,j,q,j1]
#
           ENDDO q1
#
           deallocate Lxjqj[*,j,q,j1]
#
     ENDPARDO q, j, j1
#
     sip_barrier
#
     ENDPROC TRAN_BBJJ
#    -----------------
#
     PROC TRAN_JBBJ
#    --------------
#
     sip_barrier 
#
     PARDO mu, j, j1
#
           allocate Ljxbj[j,mu,*,j1] 
#
           DO nu 
#
              GET Vjxxj[j,mu,nu,j1] 
#
              DO b
#
                 Tjxbj[j,mu,b,j1]  = Vjxxj[j,mu,nu,j1]*cb[nu,b]
                 Ljxbj[j,mu,b,j1] += Tjxbj[j,mu,b,j1]
#
              ENDDO b
#
           ENDDO nu 
#
           DO b
#
              PUT Vjxbj[j,mu,b,j1] = Ljxbj[j,mu,b,j1]
#
           ENDDO b
#
           deallocate Ljxbj[j,mu,*,j1] 
#
     ENDPARDO mu, j, j1
#
     sip_barrier
#
     PARDO b, j, j1
#
           allocate Ljbbj[j,*,b,j1] 
#
           DO mu 
#
              GET Vjxbj[j,mu,b,j1] 
#
              DO b1
#
                 Tjbbj[j,b1,b,j1]  = Vjxbj[j,mu,b,j1]*cb[mu,b1]
                 Ljbbj[j,b1,b,j1] += Tjbbj[j,b1,b,j1]
#
              ENDDO b1
#
           ENDDO mu 
#
           DO b1
#
              GET                        Vbbjj[b,b1,j,j1] 
              tjbbj[j,b1,b,j1]         = Vbbjj[b,b1,j,j1] 
              tjbbj[j,b1,b,j1]        -= Ljbbj[j,b1,b,j1]  
              tjbbj[j,b1,b,j1]        *= -1.0  
              PUT Vjbbj[j,b1,b,j1] = tjbbj[j,b1,b,j1]
#
           ENDDO b1
#
           deallocate Ljbbj[j,*,b,j1] 
#
     ENDPARDO b, j, j1
#
     sip_barrier
#
     ENDPROC TRAN_JBBJ
#    -----------------

     PROC TRAN_IABJ
#    --------------
#
     sip_barrier
#
     PARDO mu, i, j
#
           allocate Lxixj[mu,i,*,j]
           allocate Lixbj[i,mu,*,j]
#
           DO nu
#
              GET Vixxj[i,mu,nu,j] 
              GET Vxixj[mu,i,nu,j]
              Lxixj[mu,i,nu,j] = Vxixj[mu,i,nu,j]
#
              DO b
#
                 Tixbj[i,mu,b,j]  = Vixxj[i,mu,nu,j]*cb[nu,b]
                 Lixbj[i,mu,b,j] += Tixbj[i,mu,b,j]
#
              ENDDO b
#
           ENDDO nu
#
           DO b
#
              PUT Vixbj[i,mu,b,j] = Lixbj[i,mu,b,j]
#
           ENDDO b

           DO q
#
              Txiqj[mu,i,q,j] = 0.0
#
              DO nu
#
                 T1xiqj[mu,i,q,j] = Lxixj[mu,i,nu,j]*cb[nu,q]
                 Txiqj[mu,i,q,j] += T1xiqj[mu,i,q,j]
#
              ENDDO nu
#
              PUT Vxiqj[mu,i,q,j] = Txiqj[mu,i,q,j]
#
           ENDDO q
#
           deallocate Lixbj[i,mu,*,j]
           deallocate Lxixj[mu,i,*,j]
#
     ENDPARDO mu, i, j
#
     sip_barrier
#
     PARDO b, i, j
#
           allocate Liabj[i,*,b,j]
#
           DO mu
#
              GET Vixbj[i,mu,b,j] 
#
              DO a
#
                 Tiabj[i,a,b,j]  = Vixbj[i,mu,b,j]*ca[mu,a]
                 Liabj[i,a,b,j] += Tiabj[i,a,b,j]
#
              ENDDO a
#
           ENDDO mu
#
           DO a
#
              PUT Viabj[i,a,b,j] = Liabj[i,a,b,j]
#
           ENDDO a
#
           deallocate Liabj[i,*,b,j]
#
     ENDPARDO b, i, j

     PARDO q, i, j
#
           allocate Lxiqj[*,i,q,j]
#
           DO mu
#
              GET Vxiqj[mu,i,q,j] 
              Lxiqj[mu,i,q,j] = Vxiqj[mu,i,q,j]
#
           ENDDO mu
#
           DO p
#
              Tpiqj[p,i,q,j] = 0.0
#
              DO mu
#
                 T1piqj[p,i,q,j] = Lxiqj[mu,i,q,j]*ca[mu,p]
                 Tpiqj[p,i,q,j] += T1piqj[p,i,q,j]
#
              ENDDO mu
#
              PUT Vpiqj[p,i,q,j] = Tpiqj[p,i,q,j]
#
           ENDDO p
#
#
           deallocate Lxiqj[*,i,q,j]
#
     ENDPARDO q, i, j

#
     sip_barrier

     ENDPROC TRAN_IABJ
#    -----------------
#
     PROC TRAN_PPPP
#    --------------
#
          CALL TRAN_XXII
          CALL TRAN_AAII
          CALL TRAN_IAAI
#
          CALL TRAN_BBJJ
          CALL TRAN_JBBJ
#
          CALL TRAN_IABJ
#
     ENDPROC TRAN_PPPP
#    -----------------
#
     PROC TRAN_UHF 
#     -------------
# 
         CALL TRAN_PPPP  
#
     ENDPROC TRAN_UHF 
#    ----------------

     PROC READ_MO_INTS
#    -----------------

     restore_persistent VSpipi "VSpipi"
     restore_persistent Vaaii "Vaaii"
     restore_persistent Viaai "Viaai"
     restore_persistent Vaaai "Vaaai"
     restore_persistent VSaaai "VSaaai"
     restore_persistent VSbbbj "VSbbbj"
     restore_persistent VSqjqj "VSqjqj"
     restore_persistent Vbbjj "Vbbjj"
     restore_persistent Vjbbj "Vjbbj"
     restore_persistent Vbbii "Vbbii"
     restore_persistent Vjbii "Vjbii"
     restore_persistent Vbbai "Vbbai"
     restore_persistent Vpiqj "Vpiqj"
     restore_persistent Vaajj "Vaajj"
     restore_persistent Viabj "Viabj"
     restore_persistent Vaabj "Vaabj"

     ENDPROC READ_MO_INTS
#    --------------------

      PROC HC_MULT
#     ------------
      PARDO a, i
            PUT HR1A[a,i] = 0.0
      ENDPARDO a, i
#
      PARDO b, j
            PUT HR1B[b,j] = 0.0
      ENDPARDO b, j
      sip_barrier 
#
      PARDO a, i
#
            tai[a,i] = 0.0
#
            DO i1
               GET         R1A[a,i1]
               t2ai[a,i] = R1A[a,i1]*fock_a[i1,i]
               tai[a,i] -= t2ai[a,i]
            ENDDO i1
#
            DO a1
#
               GET         R1A[a1,i]
               t1ai[a,i] = R1A[a1,i]*fock_a[a,a1]
               tai[a,i] += t1ai[a,i]
#
            ENDDO a1
#
            PUT HR1A[a,i] += tai[a,i]
#
      ENDPARDO a, i
#
      PARDO b, j
#
            tbj[b,j] = 0.0
#
            DO j1
#
               GET         R1B[b,j1]
               t2bj[b,j] = R1B[b,j1]*fock_b[j1,j]
               tbj[b,j] -= t2bj[b,j]
#
            eNDDO j1
#
            DO b1
#
               GET         R1B[b1,j]
               t1bj[b,j] = R1B[b1,j]*fock_b[b,b1]
               tbj[b,j] += t1bj[b,j]
#
            ENDDO b1
#
            PUT HR1B[b,j] += tbj[b,j]
#
      ENDPARDO b, j
#
      sip_barrier  
#bgn_debug
      tmpb=0.0
      tmpa=0.0
      suma=0.0
      sumb=0.0
      pardo i,a
         get hr1a[a,i]
         Tmp =  hr1a[a,i] *  hr1a[a,i]
         tmpa += tmp
      endpardo i,a
      pardo j,b
         get hr1b[b,j]
         tmp = hr1b[b,j] * hr1b[b,j]
         tmpb += tmp
      endpardo j,b
      sip_barrier
      collective suma +=tmpa
      collective sumb +=tmpb
      sip_barrier 
      print suma
      print sumb
#end_debug
#
      PARDO a, i, b, j 
#
            GET              Viabj[i,a,b,j] 
            GET                  R1B[b,j]
            t2ai[a,i]          = Viabj[i,a,b,j]*R1B[b,j]
            PUT HR1A[a,i] += t2ai[a,i]
            GET                  R1A[a,i]
            t1bj[b,j]          =  Viabj[i,a,b,j]*R1A[a,i]
            PUT HR1B[b,j]+= t1bj[b,j]

      ENDPARDO a, i, b, j 
#
      PARDO a, i, a1, i1     
#
            GET             Viaai[i1,a1,a,i] 
            GET                 R1A[a1,i1]
            tai[a,i]          = Viaai[i1,a1,a,i]*R1A[a1,i1]
            PUT HR1A[a,i]+= tai[a,i]
#
      ENDPARDO a, i, a1, i1     
#
      PARDO b, j, b1, j1  
#
            GET             Vjbbj[j1,b1,b,j]
            GET                 R1B[b1,j1]

            tbj[b,j]          = Vjbbj[j1,b1,b,j]*R1B[b1,j1]
            PUT HR1B[b,j]+= tbj[b,j]
#
      ENDPARDO b, j, b1, j1    

      PARDO a, i, a1, i1     

            GET             VSpipi[a,i,a1,i1] 
            GET                 R1A[a1,i1]
            tai[a,i]          = VSpipi[a,i,a1,i1]*R1A[a1,i1]
            PUT HR1A[a,i]+= tai[a,i]

      ENDPARDO a, i, a1, i1     
#bgn_debug
#      tmpb=0.0
#      tmpa=0.0
#      suma=0.0
#      sumb=0.0
#      pardo i,a,i1,a1
#         GET  VSpipi[a,i,a1,i1] 
#         Tmp =   VSpipi[a,i,a1,i1] *  VSpipi[a,i,a1,i1]
#         tmpa += tmp
#      endpardo i,a,i1,a1
#      pardo j,b,b1,j1
#         GET VSqjqj[b,j,b1,j1] 
#         tmp = VSqjqj[b,j,b1,j1] * VSqjqj[b,j,b1,j1]
#         tmpb += tmp
#      endpardo j,b,b1,j1
#      sip_barrier
#      collective suma +=tmpa
#      collective sumb +=tmpb
#      sip_barrier 
#      print suma
#      print sumb
#      tmpb=0.0
#      tmpa=0.0
#      suma=0.0
#      sumb=0.0
#      pardo i,a, a1, i1
#         GET Viaai[i1,a1,a,i]
#         Tmp =   Viaai[i1,a1,a,i] * Viaai[i1,a1,a,i]
#         tmpa += tmp
#      endpardo i,a,a1,i1
#      pardo j,b,b1,j1
#         GET  Vjbbj[j1,b1,b,j]
#         tmp =  Vjbbj[j1,b1,b,j] *  Vjbbj[j1,b1,b,j]
#         tmpb += tmp
#      endpardo j,b,b1,j1
#      sip_barrier
#      collective suma +=tmpa
#      collective sumb +=tmpb
#      sip_barrier 
#      print suma
#      print sumb
#      tmpb=0.0
#      tmpa=0.0
#      suma=0.0
#      sumb=0.0
#      pardo a, i, b,j
#         GET Viabj[i,a,b,j]
#         Tmp =   Viabj[i,a,b,j] * Viabj[i,a,b,j]
#         tmpa += tmp
#      endpardo a, i, b, j
#      pardo  a, i, b, j
#         GET  Vpiqj[a,i,b,j]
#         tmp =  Vpiqj[a,i,b,j] * Vpiqj[a,i,b,j]
#         tmpb += tmp
#      endpardo a, i, b, j
#      sip_barrier
#      collective suma +=tmpa
#      collective sumb +=tmpb
#      sip_barrier 
#      print suma
#      print sumb
#end_debug
#
      PARDO a, i, b, j

            GET             Vpiqj[a,i,b,j]
            GET                 R1B[b,j]
            tai[a,i]          = Vpiqj[a,i,b,j]*R1B[b,j]
            PUT HR1A[a,i]+= tai[a,i]
            GET                 R1A[a,i]
            tbj[b,j]          = Vpiqj[a,i,b,j]*R1A[a,i]
            PUT HR1B[b,j]+= tbj[b,j]

      ENDPARDO a, i, b, j

      PARDO b, j, b1, j1
#
            GET             VSqjqj[b,j,b1,j1]
            GET                 R1B[b1,j1]
            tbj[b,j]          = VSqjqj[b,j,b1,j1]*R1B[b1,j1]
            PUT HR1B[b,j]+= tbj[b,j]
#
      ENDPARDO b, j, b1, j1

      sip_barrier 
#bgn_debug
      tmpb=0.0
      tmpa=0.0
      suma=0.0
      sumb=0.0
      pardo i,a
         get hr1a[a,i]
         Tmp =  hr1a[a,i] *  hr1a[a,i]
         tmpa += tmp
      endpardo i,a
      pardo j,b
         get hr1b[b,j]
         tmp = hr1b[b,j] * hr1b[b,j]
         tmpb += tmp
      endpardo j,b
      sip_barrier
      collective suma +=tmpa
      collective sumb +=tmpb
      sip_barrier 
      print suma
      print sumb
#end_debug
#
      ENDPROC HC_MULT
#     --------------
#
     PROC FORM_INITIAL_GUESS
#    -----------------------
     DO NROOTS 
        PARDO a, i
              INIT_RVEC_AA[a,i,NROOTS] = 0.0
              DIAGA[a,i]               = 0.0
        ENDPARDO a, i
     ENDDO NROOTS 

     DO NROOTS 
        PARDO b, j
              INIT_RVEC_BB[b,j,NROOTS] = 0.0
              DIAGB[b,j]               = 0.0
        ENDPARDO b, j
     ENDDO NROOTS 

     DO a 
     DO i
           GET R1DA[a,i]
           Tai[a,i]   = R1DA[a,i]
           DIAGA[a,i] = Tai[a,i]
     ENDDO i
     ENDDO a 

     DO b
     DO j
           GET R1DB[b,j]
           Tbj[b,j]   = R1DB[b,j]
           DIAGB[b,j] = Tbj[b,j]
     ENDDO j 
     ENDDO b
     sip_barrier  
   
     EXECUTE A4_1HP_GUESS DIAGA INIT_RVEC_AA TARGET_ROOTS
     EXECUTE A4_1HP_GUESS DIAGB INIT_RVEC_BB TARGET_ROOTS 

     sip_barrier  

     ENDPROC FORM_INITIAL_GUESS
#    --------------------------

     PROC PREP_RPA_GUESS
#    -------------------

      COUNTER = 0.0
#
# The intial guesses are stored in INIT_RVEC_AA and BB. The last 
# index correspondos to the root ID. As this routine get called from 
# the main loop with a root ID as MYROOT, the following loop
# copes the vectors correspinding to MYROOT to the working arrays.

      DO MROOTS

         COUNTER += 1.0
         IF COUNTER == MYROOT

            IF SINGLET == ONE 
               PARDO a, i 
                     Tai[a,i] =  INIT_RVEC_AA[a,i,MROOTS]
                     PUT R1a_intmd[a,i] =  Tai[a,i]
               ENDPARDO a, i

              PARDO b, j
                    Tbj[b,j]  = INIT_RVEC_BB[b,j,MROOTS]
                    PUT R1b_intmd[b,j] =  Tbj[b,j]
              ENDPARDO b, j 
            ENDIF 

            IF TRIPLET == ONE 
               PARDO a, i 
                     Tai[a,i]  =  INIT_RVEC_AA[a,i,MROOTS]
                     PUT R1a_intmd[a,i] =  Tai[a,i]
               ENDPARDO a, i

              PARDO b, j
                    Tbj[b,j]  = INIT_RVEC_BB[b,j,MROOTS]
                    Tbj[b,j] *= -1.0
                    PUT R1b_intmd[b,j] =  Tbj[b,j]
              ENDPARDO b, j 
            ENDIF 

         ENDIF

      ENDDO MROOTS

      sip_barrier 

#bgn_debug
#      tmpa = 0.0
#      do i 
#      do a
#         Get R1a_intmd[a,i]
#         tmp  = R1a_intmd[a,i] * R1a_intmd[a,i]
#         tmpa += tmp
#      enddo a
#      enddo i
#      print tmpa
#end_debug

      SUMA = 0.0
      SUMB = 0.0
      TMPA = 0.0
      TMPB = 0.0
      PARDO i, a
            GET  R1a_intmd[a,i]
            Tai[a,i] = R1a_intmd[a,i]
            TMP   = Tai[a,i] * Tai[a,i]
            TMPA += TMP
      ENDPARDO i, a

      PARDO j, b
            GET  R1b_intmd[b,j]
            Tbj[b,j] =  R1b_intmd[b,j]
            TMP   = Tbj[b,j] * Tbj[b,j]
            TMPB += TMP
      ENDPARDO j, b

      sip_barrier 
      COLLECTIVE  SUMA += TMPA
      COLLECTIVE  SUMB += TMPB

      SUMAB  = SUMA
      SUMAB += SUMB

      NORM_R   = SUMAB
      SUMAB    = NORM_R ** (HALF)
      INV_SQRT_NORM_R = SUMAB ** (MONE)

      PARDO i, a
            GET  R1a_intmd[a,i]
            Tai[a,i]  = R1a_intmd[a,i]
            Tai[a,i] *= INV_SQRT_NORM_R
            PUT R1a[a,i] = Tai[a,i]
      ENDPARDO i, a

      PARDO j, b
            GET  R1b_intmd[b,j]
            Tbj[b,j]  =  R1b_intmd[b,j]
            Tbj[b,j] *= INV_SQRT_NORM_R
            PUT  R1b[b,j] = Tbj[b,j]
      ENDPARDO j, b

      sip_barrier 

#bgn_debug
#      tmpb=0.0
#      tmpa=0.0
#      suma=0.0
#      sumb=0.0
#      pardo i,a
#         get r1a[a,i]
#         Tmp =  r1a[a,i] *  r1a[a,i]
#         tmpa += tmp
#      endpardo i,a
#      pardo j,b
#         get r1b[b,j]
#         tmp = r1b[b,j] * r1b[b,j]
#         tmpb += tmp
#      endpardo j,b
#      sip_barrier
#      collective suma +=tmpa
#      collective sumb +=tmpb
#      sip_barrier 
#      print suma
#      print sumb
#end_debug

     ENDPROC PREP_RPA_GUESS
#    ----------------------
#
     PROC FORM_DIAG
#    --------------
#
# -----PUT f_aa diagonal = Sdaa
#
     PARDO a, a1
           Saa[a,a1]      = fock_a[a,a1]
           execute return_diagonal_elements Saa[a,a1]
           taa[a,a1]      = Saa[a,a1]
           put DDaa[a,a1] = taa[a,a1]
     ENDPARDO a, a1
#
# -----PUT f_ii diagonal = Sdii
#
     PARDO i, i1
           Sii[i1,i]      = fock_a[i1,i]
           execute return_diagonal_elements Sii[i1,i]
           tii[i1,i]      = Sii[i1,i]
           put DDii[i1,i] = tii[i1,i]
     ENDPARDO i, i1
#
# -----PUT f_bb diagonal = DDbb
#
     PARDO b, b1
           Sbb[b,b1]      = fock_b[b,b1]
           execute return_diagonal_elements Sbb[b,b1]
           tbb[b,b1]      = Sbb[b,b1]
           put DDbb[b,b1] = tbb[b,b1]
     ENDPARDO b, b1
#
# -----PUT f_jj diagonal = DDjj
#
     PARDO j, j1
           Sjj[j1,j]      = fock_b[j1,j]
           execute return_diagonal_elements Sjj[j1,j]
           tjj[j1,j]      = Sjj[j1,j]
           put DDjj[j1,j] = tjj[j1,j]
     ENDPARDO j, j1
#
# -----PUT Hbar_aiai diagonal
#
     PARDO a, i
#
           tai[a,i] = 0.0
#
           do a1
           do i1
#
               GET             Viaai[i1,a1,a,i] 
               Tiaai[i1,a1,a,i]  = Viaai[i1,a1,a,i]
#
               Taaii[a,a1,i,i1]  = Tiaai[i1,a1,a,i]
               execute return_diagonal_elements  Taaii[a,a1,i,i1]
               tia[i1,a1]        = 1.0
               t1ai[a,i]         = Taaii[a,a1,i,i1]*tia[i1,a1]
               tai[a,i]         += t1ai[a,i]
#
           enddo i1
           enddo a1
#
           PUT R1DA[a,i] = tai[a,i]
#
     ENDPARDO a, i
#
# -----PUT Hbar_bjbj diagonal
#
     PARDO b, j
#
           tbj[b,j] = 0.0
#
           do b1
           do j1
#
               GET             Vjbbj[j1,b1,b,j] 
#
               Tjbbj[j1,b1,b,j]  = Vjbbj[j1,b1,b,j]
#
               Tbbjj[b,b1,j,j1]  = Tjbbj[j1,b1,b,j]
               execute return_diagonal_elements Tbbjj[b,b1,j,j1]
               tjb[j1,b1]        = 1.0
               t1bj[b,j]         = Tbbjj[b,b1,j,j1]*tjb[j1,b1]
               tbj[b,j]         += t1bj[b,j]
#
           enddo j1
           enddo b1
#
           PUT R1DB[b,j] = tbj[b,j]
#
     ENDPARDO b, j
#
     sip_barrier 
#
# ---------compute T(a,i)=F(a,a)-f(i,i)-v(a,i,a,i)
#
     PARDO a, i
#
           tai[a,i] = 0.0
#
           do a1
#
              get         DDaa[a,a1]
              tia[i,a1] = 1.0
              taa[a1,a] = DDaa[a,a1]
#
              t2ai[a,i] = tia[i,a1]*taa[a1,a]
              tai[a,i] += t2ai[a,i]
#
           enddo a1
#
           do i1
#
              get         DDii[i1,i]
              t2ia[i1,a]= 1.0
              tii[i,i1] = DDii[i1,i]
#
              t2ai[a,i] = tii[i,i1]*t2ia[i1,a]
              t2ai[a,i]*= -1.0
              tai[a,i] += t2ai[a,i]
#
           enddo i1
#
           PUT R1DA[a,i]=tai[a,i]
#
     ENDPARDO a, i
#
# ---------compute T(b,j)=F(b,b)-f(j,j)
#
     PARDO b, j
#
           tbj[b,j]=0.0
#
           do b1
#
              get         DDbb[b,b1]
              tjb[j,b1] = 1.0
              tbb[b1,b] = DDbb[b,b1]
              t2bj[b,j] = tjb[j,b1]*tbb[b1,b]
              tbj[b,j] += t2bj[b,j]
#
           enddo b1
#
           do j1
#
              get         DDjj[j1,j]
              t2jb[j1,b]= 1.0
              tjj[j,j1] = DDjj[j1,j]
              t2bj[b,j] = tjj[j,j1]*t2jb[j1,b]
              t2bj[b,j]*= -1.0
              tbj[b,j] += t2bj[b,j]
#
           enddo j1
#
           PUT R1DB[b,j] = tbj[b,j]
#
     ENDPARDO b, j
#
     sip_barrier 

     ENDPROC FORM_DIAG
#    -----------------

      PROC SAVE_C_VECTORS
#     ------------------

      NCOUNT = 0.0
      DO NINDEX50
         NCOUNT += 1.0

         IF NCOUNT == ITER_COUNT

            PARDO a, i
                  GET R1A[a,i]
                  Tai[a,i] = R1A[a,i]
                  Taix[a,i,NINDEX50] = Tai[a,i]
                  PUT R1A_HIST[a,i,NINDEX50] = Taix[a,i,NINDEX50]
            ENDPARDO a, i

            PARDO b, j
                  GET R1B[b,j]
                  Tbj[b,j] = R1B[b,j]
                  Tbjx[b,j,NINDEX50] = Tbj[b,j]
                  PUT R1B_HIST[b,j,NINDEX50] = Tbjx[b,j,NINDEX50] 
            ENDPARDO b, j
        ENDIF

      ENDDO NINDEX50

      sip_barrier  

#bgn_debug
#      ncount = 0.0
#      DO NINDEX50
#      ncount += 1.0
#      if ncount <= iter_count
#      print ncount
#      pardo i,a
#         get r1a_hist[a,i,NINDEX50]
#         Tmp =   r1a_hist[a,i,NINDEX50] *  r1a_hist[a,i,NINDEX50]
#         tmpa += tmp
#      endpardo i,a
#      pardo j,b
#        get r1b_hist[b,j,NINDEX50]
#         tmp =  r1b_hist[b,j,NINDEX50] * r1b_hist[b,j,NINDEX50]
#         tmpb += tmp
#      endpardo j,b
#      sip_barrier
#      collective suma +=tmpa
#      collective sumb +=tmpb
#      print suma
#      print sumb
#      endif
#      ENDDO NINDEX50
#end_debug

      ENDPROC SAVE_C_VECTORS
#     --------------------

      PROC SAVE_HC_VECTORS
#     --------------------

      NCOUNT = 0.0
      DO NINDEX50
         NCOUNT += 1.0

         IF NCOUNT == ITER_COUNT

             PARDO a, i
                  GET HR1A[a,i]
                  Tai[a,i] = HR1A[a,i]
                  PUT HR1A_HIST[a,i,NINDEX50] = Tai[a,i]
             ENDPARDO a, i

             PARDO b, j
                  GET HR1B[b,j]
                  Tbj[b,j] = HR1B[b,j]
                  PUT HR1B_HIST[b,j,NINDEX50] = Tbj[b,j]
             ENDPARDO b, j
        ENDIF

      ENDDO NINDEX50

      sip_barrier 

#bgn_debug
#      ncount = 0.0
#      DO NINDEX50
#      ncount += 1.0
#      if ncount <= iter_count 
#      tmpb=0.0
#      tmpa=0.0
#      suma=0.0
#      sumb=0.0
#      pardo i,a
#         get hr1a_hist[a,i,NINDEX50]
#         Tmp =   hr1a_hist[a,i,NINDEX50] *  hr1a_hist[a,i,NINDEX50] 
#         tmpa += tmp
#      endpardo i,a
#      pardo j,b
#         get hr1b_hist[b,j,NINDEX50]
#         tmp =  hr1b_hist[b,j,NINDEX50] * hr1b_hist[b,j,NINDEX50]
#         tmpb += tmp
#      endpardo j,b
#      sip_barrier
#      collective suma +=tmpa
#      collective sumb +=tmpb
#      print suma
#      print sumb
#      endif 
#      ENDDO NINDEX50
#end_debug


      ENDPROC SAVE_HC_VECTORS
#     -----------------------
#
     PROC FORM_A_MATRIX_11
#    ----------------------

     SUMA   = 0.0
     SUMB   = 0.0
     HC_A   = 0.0
     HC_B   = 0.0

# Build A(1,1) for the first iteraion

        NCOUNT = 0.0
        DO NINDEX50
           NCOUNT += 1.0
           IF NCOUNT == ITER_COUNT

              MCOUNT = 0.0
              DO MINDEX50
                 MCOUNT += 1.0
                 IF MCOUNT == ITER_COUNT

                    PARDO i, a

                          GET HR1A_HIST[a,i,NINDEX50]
                          GET R1A_HIST[a,i,MINDEX50]

                          Tai[a,i]   = HR1A_HIST[a,i,NINDEX50]
                          T1ai[a,i]  = R1A_HIST[a,i,MINDEX50]

                          TMP   = Tai[a,i] *  T1ai[a,i]
                          SUMA += TMP

                    ENDPARDO i, a

                    PARDO j, b

                          GET HR1B_HIST[b,j,NINDEX50]
                          GET R1B_HIST[b,j,MINDEX50]

                          Tbj[b,j]   = HR1B_HIST[b,j,NINDEX50]
                          T1bj[b,j]  = R1B_HIST[b,j,MINDEX50]

                          TMP   = Tbj[b,j] * T1bj[b,j]
                          SUMB += TMP

                    ENDPARDO j, b

                    SIP_BARRIER
                    COLLECTIVE HC_A += SUMA
                    COLLECTIVE HC_B += SUMB

                 ENDIF

              ENDDO MINDEX50
           ENDIF

        ENDDO NINDEX50

     A_VALUE  = HC_A
     A_VALUE += HC_B
#bgn_debug
#     print A_value
#end_debug

     NCOUNT = 0.0
     MCOUNT = 0.0

     DO NINDEX50
         NCOUNT += 1.0
         IF NCOUNT == 1.0

            DO MINDEX50
               MCOUNT += 1.0
               IF MCOUNT == 1.0

                   A_MATRIX[MINDEX50,NINDEX50] = A_VALUE

                ENDIF
             ENDDO MINDEX50
         ENDIF
     ENDDO NINDEX50

     sip_barrier 

     ENDPROC FORM_A_MATRIX_11
#    ------------------------

     PROC  FORM_A_MATRIX_IJ
#    ---------------------

     NCOUNT = 0.0
     DO NINDEX50
        NCOUNT += 1.0
        IF NCOUNT > ITER_COUNT
           EXIT
        ENDIF
              MCOUNT = 0.0
              DO MINDEX50
                 MCOUNT += 1.0

                 IF MCOUNT > NCOUNT
                    EXIT
                 ENDIF

                 IF MCOUNT == ITER_COUNT
                    IF NCOUNT == ITER_COUNT
                       EXIT
                    ENDIF
                 ENDIF

                    SUMA   = 0.0
                    SUMB   = 0.0
                    HC_A   = 0.0
                    HC_B   = 0.0

                     PARDO i, a

                          GET HR1A_HIST[a,i,NINDEX50]
                          GET R1A_HIST[a,i,MINDEX50]

                          Tai[a,i]   = HR1A_HIST[a,i,NINDEX50]
                          T1ai[a,i]  = R1A_HIST[a,i,MINDEX50]

                          TMP   = Tai[a,i] *  T1ai[a,i]
                          SUMA += TMP

                    ENDPARDO i, a

                    PARDO j, b

                          GET HR1B_HIST[b,j,NINDEX50]
                          GET R1B_HIST[b,j,MINDEX50]

                          Tbj[b,j]   = HR1B_HIST[b,j,NINDEX50]
                          T1bj[b,j]  = R1B_HIST[b,j,MINDEX50]

                          TMP   = Tbj[b,j] * T1bj[b,j]
                          SUMB += TMP

                    ENDPARDO j, b

                    SIP_BARRIER
                    COLLECTIVE HC_A += SUMA
                    COLLECTIVE HC_B += SUMB
                    
                    A_VALUE  = HC_A
                    A_VALUE += HC_B

                    KCOUNT = 0.0
                    DO KINDEX50
                        KCOUNT += 1.0
                        IF KCOUNT  == NCOUNT

                           LCOUNT = 0.0
                           DO LINDEX50
                              LCOUNT += 1.0
                              IF LCOUNT == MCOUNT

                                 A_MATRIX[MINDEX50,NINDEX50] = A_VALUE

                              ENDIF
                           ENDDO LINDEX50
                        ENDIF
                    ENDDO KINDEX50

              ENDDO MINDEX50
     ENDDO NINDEX50

     sip_barrier 

     ENDPROC  FORM_A_MATRIX_IJ
#    -------------------------

     PROC FORM_A_MATRIX_JI
#    ----------------------

# Built A_jk where k=1, ..j-1, <(HC_k)_j | C_k>

     NCOUNT = 0.0
     DO NINDEX50
        NCOUNT += 1.0
        IF NCOUNT > ITER_COUNT
           EXIT
        ENDIF

              MCOUNT = 0.0
              DO MINDEX50
                 MCOUNT += 1.0

                 IF MCOUNT >= NCOUNT
                    EXIT
                 ENDIF

                 IF MCOUNT == ITER_COUNT
                    IF NCOUNT == ITER_COUNT
                       EXIT
                    ENDIF
                 ENDIF

                    SUMA   = 0.0
                    SUMB   = 0.0
                    HC_A   = 0.0
                    HC_B   = 0.0

                     PARDO i, a

                            GET HR1A_HIST[a,i,MINDEX50]
                            GET R1A_HIST[a,i,NINDEX50]

                            Tai[a,i]   = HR1A_HIST[a,i,MINDEX50]
                            T1ai[a,i]  = R1A_HIST[a,i,NINDEX50]

                            TMP   = Tai[a,i] * T1ai[a,i]
                            SUMA += TMP

                     ENDPARDO i, a

                     PARDO j, b

                           GET HR1B_HIST[b,j,MINDEX50]
                           GET R1B_HIST[b,j,NINDEX50]

                           Tbj[b,j]  = HR1B_HIST[b,j,MINDEX50]
                           T1bj[b,j] = R1B_HIST[b,j,NINDEX50]

                           TMP   = Tbj[b,j] * T1bj[b,j]
                           SUMB += TMP

                     ENDPARDO j, b

                     SIP_BARRIER
                     COLLECTIVE HC_A += SUMA
                     COLLECTIVE HC_B += SUMB

                     A_VALUE  = HC_A
                     A_VALUE += HC_B

                     KCOUNT = 0.0
                     DO KINDEX50
                         KCOUNT += 1.0
                         IF KCOUNT  == NCOUNT

                            LCOUNT = 0.0
                            DO LINDEX50
                               LCOUNT += 1.0
                               IF LCOUNT == MCOUNT

                                  A_MATRIX[NINDEX50,MINDEX50] = A_VALUE

                               ENDIF
                            ENDDO LINDEX50
                         ENDIF
                     ENDDO KINDEX50

              ENDDO MINDEX50
     ENDDO NINDEX50

     sip_barrier 

     ENDPROC  FORM_A_MATRIX_JI
#    -------------------------

     PROC  FORM_A_MATRIX_II
#    ----------------------

     SUMA   = 0.0
     SUMB   = 0.0
     HC_A   = 0.0
     HC_B   = 0.0

     MCOUNT = 0.0
     DO MINDEX50
        MCOUNT += 1.0
        IF MCOUNT == ITER_COUNT

              NCOUNT = 0.0
              DO NINDEX50
                 NCOUNT += 1.0
                 IF NCOUNT == MCOUNT

                    SUMA   = 0.0
                    SUMB   = 0.0
                    HC_A   = 0.0
                    HC_B   = 0.0

                    PARDO i, a

                          GET HR1A_HIST[a,i,NINDEX50]
                          GET R1A_HIST[a,i,MINDEX50]

                          Tai[a,i]   = HR1A_HIST[a,i,NINDEX50]
                          T1ai[a,i]  = R1A_HIST[a,i,MINDEX50]

                          TMP   = Tai[a,i] *  T1ai[a,i]
                          SUMA += TMP

                    ENDPARDO i, a

                    PARDO j, b

                          GET HR1B_HIST[b,j,NINDEX50]
                          GET R1B_HIST[b,j,MINDEX50]

                          Tbj[b,j]   = HR1B_HIST[b,j,NINDEX50]
                          T1bj[b,j]  = R1B_HIST[b,j,MINDEX50]

                          TMP   = Tbj[b,j] * T1bj[b,j]
                          SUMB += TMP

                    ENDPARDO j, b

                    SIP_BARRIER
                    COLLECTIVE HC_A += SUMA
                    COLLECTIVE HC_B += SUMB

                    A_VALUE  = HC_A
                    A_VALUE += HC_B
  
                     KCOUNT = 0.0
                     DO KINDEX50
                         KCOUNT += 1.0
                         IF KCOUNT  == NCOUNT

                            LCOUNT = 0.0
                            DO LINDEX50
                               LCOUNT += 1.0
                               IF LCOUNT == MCOUNT

                                  A_MATRIX[NINDEX50,MINDEX50] = A_VALUE

                               ENDIF
                            ENDDO LINDEX50
                         ENDIF
                     ENDDO KINDEX50
                ENDIF
              ENDDO NINDEX50
       ENDIF

     ENDDO MINDEX50
     sip_barrier 

     ENDPROC  FORM_A_MATRIX_II
#    -------------------------

     PROC FORM_NEWVECS_ITR1
#    ----------------------

     OMEGA0   = A_VALUE
     OMEGA0M  = A_VALUE
     OMEGA0M *= -1.0

# First the residual vector for iteration 1
    
     PARDO i, a

           NCOUNT = 0.0
           DO NINDEX50
              NCOUNT += 1.0

              IF NCOUNT > 1.0
                 EXIT
              ENDIF

              GET HR1A_HIST[a,i,NINDEX50]
              GET R1A_HIST[a,i,NINDEX50]

              Tai[a,i]   = HR1A_HIST[a,i,NINDEX50]
              T1ai[a,i]  = R1A_HIST[a,i,NINDEX50]
              T1ai[a,i] *= OMEGA0M
              Tai[a,i]  += T1ai[a,i]

              PUT RES1a[a,i] = Tai[a,i]

           ENDDO NINDEX50
     ENDPARDO i, a


     PARDO j, b

           NCOUNT = 0.0
           DO NINDEX50
              NCOUNT += 1.0

              IF NCOUNT > 1.0
                 EXIT
              ENDIF

              GET HR1B_HIST[b,j,NINDEX50]
              GET R1B_HIST[b,j,NINDEX50]

              Tbj[b,j]   = HR1B_HIST[b,j,NINDEX50]
              T1bj[b,j]  = R1B_HIST[b,j,NINDEX50]
              T1bj[b,j] *= OMEGA0M
              Tbj[b,j]  += T1bj[b,j]

              PUT RES1b[b,j] = Tbj[b,j]

           ENDDO NINDEX50
     ENDPARDO  j, b

     sip_barrier  

#bgn_debug
#      tmpb=0.0
#      tmpa=0.0
#      suma=0.0
#      sumb=0.0
#      pardo i,a
#         get res1a[a,i]
#         Tmp =  res1a[a,i] * res1a[a,i]
#         tmpa += tmp
#      endpardo i,a
#      pardo j,b
#         get  res1b[b,j]
#         tmp = res1b[b,j] * res1b[b,j]
#         tmpb += tmp
#      endpardo j,b
#      sip_barrier
#      collective suma +=tmpa
#      collective sumb +=tmpb
#      sip_barrier
#      print suma
#      print sumb
#end_debug

# Now the correction vector for iteration 1

     PARDO a, i
           GET RES1a[a,i]
           GET R1DA[a,i]

           Tai[a,i]   = R1DA[a,i]
           T1ai[a,i]  = RES1a[a,i]

           Tai[a,i]  *= -1.0
           T2ai[a,i]  = OMEGA0
           Tai[a,i]  += T2ai[a,i]

           EXECUTE A4_APPLY_DENOMINATOR  T1ai[a,i] Tai[a,i] Tai[a,i] AA

           PUT CORR_VECa[a,i] =  T1ai[a,i]
      ENDPARDO a, i

      PARDO b, j
            GET RES1b[b,j]
            GET R1DB[b,j]

            Tbj[b,j]   = R1DB[b,j]
            T1bj[b,j]  = RES1b[b,j]

            Tbj[b,j]  *= -1.0
            T2bj[b,j]  = OMEGA0
            Tbj[b,j]  += T2bj[b,j]

            EXECUTE A4_APPLY_DENOMINATOR  T1bj[b,j] Tbj[b,j] Tbj[b,j]  BB

            PUT CORR_VECb[b,j] =  T1bj[b,j]
      ENDPARDO b, j

     sip_barrier  

#bgn_debug
#      tmpb=0.0
#      tmpa=0.0
#      suma=0.0
#      sumb=0.0
#      pardo i,a
#         get corr_veca[a,i]
#         Tmp =  corr_veca[a,i] * corr_veca[a,i]
#         tmpa += tmp
#      endpardo i,a
#      pardo j,b
#         get  corr_vecb[b,j]
#         tmp = corr_vecb[b,j] * corr_vecb[b,j] 
#         tmpb += tmp
#      endpardo j,b
#      sip_barrier
#      collective suma +=tmpa
#      collective sumb +=tmpb
#      sip_barrier 
#      print suma
#      print sumb
#end_debug


# Orthognalize to the Guess vector; first get the norm.

     SUMA   = 0.0
     SUMB   = 0.0
     HC_A   = 0.0
     HC_B   = 0.0

     PARDO i, a
           GET CORR_VECa[a,i]

           NCOUNT = 0.0
           DO NINDEX50
              NCOUNT += 1.0

              IF NCOUNT > 1.0
                 EXIT
              ENDIF

              GET R1A_HIST[a,i,NINDEX50]

              Tai[a,i]   = CORR_VECa[a,i]
              T1ai[a,i]  = R1A_HIST[a,i,NINDEX50]
              TMP   = Tai[a,i] * T1ai[a,i]
              SUMA += TMP

           ENDDO NINDEX50
     ENDPARDO i, a

     PARDO j, b

           GET CORR_VECb[b,j]

           NCOUNT = 0.0
           DO NINDEX50
              NCOUNT += 1.0

              IF NCOUNT > 1.0
                 EXIT
              ENDIF

              GET R1B_HIST[b,j,NINDEX50]

              Tbj[b,j]   = CORR_VECb[b,j]
              T1bj[b,j]  = R1B_HIST[b,j,NINDEX50]
              TMP  = Tbj[b,j] * T1bj[b,j]
              SUMB += TMP

           ENDDO NINDEX50
     ENDPARDO  j,b

     sip_barrier 
     COLLECTIVE  HC_A += SUMA
     COLLECTIVE  HC_B += SUMB

     NORM_GHG  = HC_A
     NORM_GHG += HC_B
#
# Orthogonalization  (i.e. <G|HG> = 0.0) (G=Guess vectors)
#
     PARDO i, a

           GET CORR_VECa[a,i]
           Tai[a,i] = 0.0

           NCOUNT = 0.0
           DO NINDEX50
              NCOUNT += 1.0

              IF NCOUNT > 1.0
                 EXIT
              ENDIF

              GET R1A_HIST[a,i,NINDEX50]

              Tai[a,i]   = CORR_VECa[a,i]
              T1ai[a,i]  = R1A_HIST[a,i,NINDEX50]
              T1ai[a,i] *= NORM_GHG
              T1ai[a,i] *= -1.0
              Tai[a,i]  += T1ai[a,i]

           ENDDO NINDEX50

          PUT R1a_intmd[a,i] = Tai[a,i]
     ENDPARDO i, a

     PARDO j, b

           GET CORR_VECb[b,j]
           Tbj[b,j] = 0.0

           NCOUNT = 0.0
           DO NINDEX50
              NCOUNT += 1.0

              IF NCOUNT > 1.0
                 EXIT
              ENDIF

              GET R1B_HIST[b,j,NINDEX50]

              Tbj[b,j]   = CORR_VECb[b,j]
              T1bj[b,j]  = R1B_HIST[b,j,NINDEX50]
              T1bj[b,j] *= NORM_GHG
              T1bj[b,j] *= -1.0
              Tbj[b,j]  += T1bj[b,j]

           ENDDO NINDEX50

           PUT R1b_intmd[b,j] = Tbj[b,j]
     ENDPARDO  j, b

    sip_barrier 

# Final normalization

     SUMA = 0.0
     SUMB = 0.0
     TMPA = 0.0
     TMPB = 0.0
     PARDO i, a

            GET  R1a_intmd[a,i]
            Tai[a,i] = R1a_intmd[a,i]
            TMP   = Tai[a,i] * Tai[a,i]
            TMPA += TMP

     ENDPARDO i, a

     PARDO j, b

           GET  R1b_intmd[b,j]
           Tbj[b,j] =  R1b_intmd[b,j]
           TMP   = Tbj[b,j] * Tbj[b,j]
           TMPB += TMP

     ENDPARDO j, b

     sip_barrier 
     COLLECTIVE  SUMA += TMPA
     COLLECTIVE  SUMB += TMPB

     SUM_R  = SUMA
     SUM_R += SUMB

     NORM_FAC = SUM_R ** (HALF)
     INV_SQRT_NORM_R = NORM_FAC ** (MONE)
#bgn_debug
#     print SUM_R
#end_debug

     PARDO i, a

            GET  R1a_intmd[a,i]
            Tai[a,i]  = R1a_intmd[a,i]
            Tai[a,i] *= INV_SQRT_NORM_R
            PUT R1a[a,i] = Tai[a,i]

      ENDPARDO i, a

      PARDO j, b

            GET  R1b_intmd[b,j]
            Tbj[b,j]  =  R1b_intmd[b,j]
            Tbj[b,j] *=  INV_SQRT_NORM_R
            PUT  R1b[b,j] = Tbj[b,j]

      ENDPARDO j, b

      sip_barrier 
#bgn_debug
      tmpb=0.0
      tmpa=0.0
      suma=0.0
      sumb=0.0
      pardo i,a
         get r1a[a,i]
         Tmp =  r1a[a,i] *  r1a[a,i]
         tmpa += tmp
      endpardo i,a
      pardo j,b
         get r1b[b,j]
         tmp = r1b[b,j] * r1b[b,j]
         tmpb += tmp
      endpardo j,b
      sip_barrier
      collective suma +=tmpa
      collective sumb +=tmpb
      sip_barrier 
      print suma
      print sumb
#end_debug

     ENDPROC FORM_NEWVECS_ITR1
#    ------------------------

    PROC REORDER_A_EIGS
#    -------------------

     DO MINDEX50
        DO NINDEX50
           IF MINDEX50  == NINDEX50
              TXX[MINDEX50,MINDEX50] = A_MATRIX[MINDEX50,MINDEX50]
              EXECUTE RETURN_SVAL TXX[MINDEX50,MINDEX50] EIG_VALUE
              A_DIAGS[MINDEX50]      = EIG_VALUE
           ENDIF
         ENDDO NINDEX50
     ENDDO MINDEX50
#
# Reorder the eigevalues and the correspoinding eigenvectors in descending
# order.

     REORD_FLAG = 1.0
     EXECUTE A4_REORD_EIGS  A_DIAGS DVECTORS ITER_COUNT REORD_FLAG

     ENDPROC REORDER_A_EIGS
#    ----------------------

     PROC FORM_NEWVECS
#    ------------------
     PARDO i, a

           NCOUNT = 0.0
           DO NINDEX50
              NCOUNT += 1.0

              IF NCOUNT > ITER_COUNT
                 EXIT
              ENDIF

                 MCOUNT = 0.0
                 DO MINDEX50
                    MCOUNT += 1.0

                    IF MCOUNT > ITER_COUNT
                       EXIT
                    ENDIF

                       TS[MINDEX50,NINDEX50] = DVECTORS[MINDEX50,NINDEX50]
                       GET R1A_HIST[a,i,MINDEX50]
                       Taix[a,i,MINDEX50]  = R1A_HIST[a,i,MINDEX50]
                       T1aix[a,i,NINDEX50] = Taix[a,i,MINDEX50] * TS[MINDEX50,NINDEX50]
                       PUT Y1A[a,i,NINDEX50] += T1aix[a,i,NINDEX50]

                 ENDDO  MINDEX50
           ENDDO NINDEX50
     ENDPARDO i, a

     PARDO j, b

           NCOUNT = 0.0
           DO NINDEX50
              NCOUNT += 1.0

              IF NCOUNT > ITER_COUNT
                 EXIT
              ENDIF

                 MCOUNT = 0.0
                 DO MINDEX50
                    MCOUNT += 1.0

                    IF MCOUNT > ITER_COUNT
                       EXIT
                    ENDIF

                       TS[MINDEX50,NINDEX50] = DVECTORS[MINDEX50,NINDEX50]
                       GET R1B_HIST[b,j,MINDEX50]
                       Tbjx[b,j,MINDEX50]  = R1B_HIST[b,j,MINDEX50]
                       T1bjx[b,j,NINDEX50] = Tbjx[b,j,MINDEX50] * TS[MINDEX50,NINDEX50]
                       PUT Y1B[b,j,NINDEX50] += T1bjx[b,j,NINDEX50]

                 ENDDO  MINDEX50
           ENDDO NINDEX50
     ENDPARDO  j, b
     sip_barrier  

#bgn_debug
      ncount = 0.0
      DO NINDEX50
      ncount += 1.0
      if ncount <= iter_count
      tmpb=0.0
      tmpa=0.0
      suma=0.0
      sumb=0.0
       pardo i,a
         get y1a[a,i,NINDEX50]
         Tmp =   y1a[a,i,NINDEX50] *  y1a[a,i,NINDEX50]
         tmpa += tmp
      endpardo i,a
      pardo j,b
        get y1b[b,j,NINDEX50]
         tmp =  y1b[b,j,NINDEX50] * y1b[b,j,NINDEX50]
         tmpb += tmp
      endpardo j,b
      sip_barrier
      collective suma +=tmpa
      collective sumb +=tmpb
      print suma
      print sumb
      endif
      ENDDO NINDEX50
#end_debug


     ENDPROC FORM_NEWVECS
#    ---------------------

    PROC SELECT_VECS
#    ----------------
     NCOUNT = 0.0
     DO NINDEX50
        NCOUNT += 1.0
        IF NCOUNT  > 1.0
           EXIT
        ENDIF

           MCOUNT = 0.0
           DO MINDEX50
              MCOUNT += 1.0
              IF MCOUNT >  ITER_COUNT
                 EXIT
              ENDIF

                 SUMA   = 0.0
                 SUMB   = 0.0
                 CY_A   = 0.0
                 CY_B   = 0.0

                 PARDO a, i

                       GET R1A_HIST[a,i,NINDEX50]
                       GET Y1a[a,i,MINDEX50]

                       Tai[a,i]  = R1A_HIST[a,i,NINDEX50]
                       T1ai[a,i] = Y1a[a,i,MINDEX50]

                       TMP   =  Tai[a,i] * T1ai[a,i]
                       SUMA +=  TMP

                  ENDPARDO a, i

                  PARDO j, b

                       GET R1b_HIST[b,j,NINDEX50]
                       GET Y1b[b,j,MINDEX50]

                       Tbj[b,j]  = R1b_HIST[b,j,NINDEX50]
                       T1bj[b,j] = Y1b[b,j,MINDEX50]

                       TMP    =  Tbj[b,j] * T1bj[b,j]
                       SUMB   +=  TMP

                  ENDPARDO j, b

                  SIP_BARRIER 
                  COLLECTIVE CY_B += SUMB
                  COLLECTIVE CY_A += SUMA

                  CY_AB  = CY_A
                  CY_AB += CY_B

                  KCOUNT = 0.0
                  DO KINDEX50
                     KCOUNT += 1.0

                     IF KCOUNT == MCOUNT
                        OVERLAP_R[MINDEX50] = CY_AB
                     ENDIF

                  ENDDO KINDEX50

           ENDDO  MINDEX50

     ENDDO NINDEX50

     sip_barrier 

     EXECUTE A4_SELECT_MAX OVERLAP_R ITER_COUNT IMAX
#bgn_debug
     print imax
#end_debug

     ENDPROC SELECT_VECS
#    -------------------

     PROC FORM_SELECTED_Y
#    --------------------

     NCOUNT = 0.0
     DO NINDEX50
        NCOUNT += 1.0
        IF NCOUNT == IMAX

           PARDO i, a

                 GET Y1a[a,i,NINDEX50]
                 Tai[a,i] = Y1a[a,i,NINDEX50]
                 PUT Y1a_PICKED[a,i] = Tai[a,i]

           ENDPARDO i, a
        ENDIF
     ENDDO NINDEX50

     NCOUNT = 0.0
     DO NINDEX50
        NCOUNT += 1.0
        IF NCOUNT == IMAX

           PARDO j, b

                 GET Y1b[b,j,NINDEX50]
                 Tbj[b,j] = Y1b[b,j,NINDEX50]
                 PUT Y1b_PICKED[b,j] = Tbj[b,j]

           ENDPARDO j, b
        ENDIF
     ENDDO NINDEX50

     sip_barrier 

     ENDPROC FORM_SELECTED_Y
#    -----------------------

      PROC FORM_HBAR_Y_VECS
#    ---------------------

      PARDO a, i
         GET Y1a_PICKED[a,i]
         Tai[a,i] = Y1a_PICKED[a,i]
         PUT R1a[a,i] =  Tai[a,i]
      ENDPARDO a, i

      PARDO b, j
         GET Y1b_PICKED[b,j]
         Tbj[b,j] = Y1b_PICKED[b,j]
         PUT R1b[b,j] =  Tbj[b,j]
      ENDPARDO b, j

      sip_barrier 

      CALL HC_MULT

      PARDO a, i
         GET HR1a[a,i]
         Tai[a,i] = HR1a[a,i]
         PUT  HY1a_PICKED[a,i] =  Tai[a,i]
      ENDPARDO a, i

      PARDO b, j
         GET HR1b[b,j]
         Tbj[b,j] = HR1b[b,j]
         PUT HY1B_PICKED[b,j] =  Tbj[b,j]
      ENDPARDO b, j
   
      sip_barrier 

      ENDPROC FORM_HBAR_Y_VECS
#    -------------------------

     PROC FORM_RESIDUAL_VEC
#    ----------------------

      EXECUTE A4_RETURN_SELECT A_DIAGS ITER_COUNT IMAX
      OMEGA   = IMAX
      OMEGAM  = OMEGA
      OMEGAM *= -1.0
#bgn_debug
     print OMEGAM
#end_debug

     PARDO a,i
           GET HY1a_picked[a,i]
           GET Y1a_picked[a,i]

           Tai[a,i]   = HY1a_picked[a,i]
           T1ai[a,i]  = Y1a_picked[a,i]
           T1ai[a,i] *= Omegam
           Tai[a,i]  +=  T1ai[a,i]
           PUT RES1a[a,i] =  Tai[a,i]
     ENDPARDO a,i

     PARDO b, j

            GET HY1b_picked[b,j]
            GET Y1b_picked[b,j]
            Tbj[b,j]   = HY1b_picked[b,j]
            T1bj[b,j]  = Y1b_picked[b,j]
            T1bj[b,j] *= Omegam
            Tbj[b,j]  += T1bj[b,j]
            PUT RES1b[b,j] =  Tbj[b,j]
     ENDPARDO b, j
     sip_barrier 

     ENDPROC FORM_RESIDUAL_VEC
#    -----------------------

     PROC CHECK_CONVERGENCE
#    -----------------------

     SUMA   = 0.0
     SUMB   = 0.0
     HC_A   = 0.0
     HC_B   = 0.0

     PARDO i, a

           GET RES1a[a,i]

           Tai[a,i]   = RES1a[a,i]

           TMP   = Tai[a,i] * Tai[a,i]
           SUMA += TMP

     ENDPARDO i, a
   
     PARDO j, b

           GET RES1b[b,j]

           Tbj[b,j]  = RES1b[b,j]

           TMP   = Tbj[b,j] * Tbj[b,j]
           SUMB += TMP

     ENDPARDO j, b

     SIP_BARRIER
     COLLECTIVE HC_A += SUMA
     COLLECTIVE HC_B += SUMB

     A_VALUE  = HC_A
     A_VALUE += HC_B

     sip_barrier 
     RESIDUAL_NORM = A_VALUE ** (HALF)

     ENDPROC CHECK_CONVERGENCE
#    -------------------------

     PROC FORM_CORRECTION_VEC
#    ------------------------
#bgn_debug
#     print OMEGA
#end_debug

     PARDO a, i
           GET RES1a[a,i]
           GET R1DA[a,i]

           Tai[a,i]   = R1DA[a,i]
           T1ai[a,i]  = RES1a[a,i]

           Tai[a,i]  *= -1.0
           T2ai[a,i]  = OMEGA
           Tai[a,i]  += T2ai[a,i]

           EXECUTE A4_APPLY_DENOMINATOR T1ai[a,i] Tai[a,i] Tai[a,i] AA

           PUT CORR_VECa[a,i] =  T1ai[a,i]
     ENDPARDO a, i

     PARDO b, j
            GET RES1b[b,j]
            GET R1DB[b,j]

            Tbj[b,j]   = R1DB[b,j]
            T1bj[b,j]  = RES1b[b,j]

            Tbj[b,j]  *= -1.0
            T2bj[b,j]  = OMEGA
            Tbj[b,j]  += T2bj[b,j]

            EXECUTE A4_APPLY_DENOMINATOR T1bj[b,j] Tbj[b,j] Tbj[b,j] BB

            PUT CORR_VECb[b,j] =  T1bj[b,j]
     ENDPARDO b, j

     sip_barrier 

     ENDPROC FORM_CORRECTION_VEC
#    ---------------------------

     PROC MAKE_ORTHO_COEFS
#    ---------------------

     NCOUNT = 0.0
     DO NINDEX50
        NCOUNT += 1.0

        IF NCOUNT > ITER_COUNT
           EXIT
        ENDIF

           PARDO i, a

                 GET R1A_HIST[a,i,NINDEX50]
                 GET CORR_VECa[a,i]

                 Tai[a,i]  = R1A_HIST[a,i,NINDEX50]
                 T1ai[a,i] = CORR_VECa[a,i]
                 TMP          = Tai[a,i] * T1ai[a,i]

                 Txx[NINDEX50,NINDEX50]         = TMP
                 PUT ORTHO_COEF[NINDEX50,NINDEX50] += Txx[NINDEX50,NINDEX50]

           ENDPARDO i, a

           PARDO j, b

                 GET R1B_HIST[b,j,NINDEX50]
                 GET CORR_VECb[b,j]

                 Tbj[b,j]  = R1B_HIST[b,j,NINDEX50]
                 T1bj[b,j] = CORR_VECb[b,j]
                 TMP          = Tbj[b,j] * T1bj[b,j]

                 Txx[NINDEX50,NINDEX50]         = TMP
                  PUT ORTHO_COEF[NINDEX50,NINDEX50] += Txx[NINDEX50,NINDEX50]

           ENDPARDO j, b
     ENDDO NINDEX50

     sip_barrier 

     ENDPROC MAKE_ORTHO_COEFS
#    ------------------------

     PROC GRAM_SCHMIDT
#    ----------------
     MCOUNT = 0.0
     SUMA   = 0.0
     SUMB   = 0.0
     C_A    = 0.0
     C_B    = 0.0

     PARDO i, a
           GET CORR_VECa[a,i]
           Tai[a,i]   = CORR_VECa[a,i]

           NCOUNT = 0.0
           DO NINDEX50
              NCOUNT += 1.0
  
              IF NCOUNT > ITER_COUNT
                 EXIT
              ENDIF

              GET R1A_HIST[a,i,NINDEX50]
              GET ORTHO_COEF[NINDEX50,NINDEX50]

              T1ai[a,i]  = R1A_HIST[a,i,NINDEX50]
              Txx[NINDEX50,NINDEX50] = ORTHO_COEF[NINDEX50,NINDEX50]

              EXECUTE RETURN_SVAL Txx[NINDEX50,NINDEX50] FACT

              T1ai[a,i] *= FACT
              T1ai[a,i] *= -1.0
              Tai[a,i]  += T1ai[a,i]

           ENDDO NINDEX50

           PUT R1a_INTMD[a,i] = Tai[a,i]

           TMP    = Tai[a,i] * Tai[a,i]
           SUMA  += TMP

     ENDPARDO i, a

     sip_barrier 

     PARDO j, b
          GET CORR_VECb[b,j]
          Tbj[b,j]  = CORR_VECb[b,j]

          NCOUNT = 0.0
          DO NINDEX50
             NCOUNT += 1.0

             IF NCOUNT > ITER_COUNT
                EXIT
             ENDIF

             GET R1B_HIST[b,j,NINDEX50]
             GET ORTHO_COEF[NINDEX50,NINDEX50]

             T1bj[b,j] = R1B_HIST[b,j,NINDEX50]
             Txx[NINDEX50,NINDEX50] = ORTHO_COEF[NINDEX50,NINDEX50]

             EXECUTE RETURN_SVAL Txx[NINDEX50,NINDEX50] FACT

             T1bj[b,j] *= FACT
             T1bj[b,j] *= -1.0
             Tbj[b,j]  += T1bj[b,j]

          ENDDO NINDEX50

          PUT R1b_INTMD[b,j] = Tbj[b,j]

          TMP   = Tbj[b,j] * Tbj[b,j] 
          SUMB += TMP

     ENDPARDO j, b

     SIP_BARRIER
     COLLECTIVE   C_A += SUMA
     COLLECTIVE   C_B += SUMB

     NORM_NEW_ORTGC  = C_A
     NORM_NEW_ORTGC += C_B

     SQRT_OVERLAP = NORM_NEW_ORTGC ** (HALF)
     INV_SQRT_NORM_ORTGC  = SQRT_OVERLAP ** (MONE)
#bgn_debug
#     print INV_SQRT_NORM_ORTGC
#     print SQRT_OVERLAP
#end_debug

     ENDPROC GRAM_SCHMIDT
#    --------------------

     PROC DRIVE_ORTHO
#    ----------------

     CALL MAKE_ORTHO_COEFS
     CALL GRAM_SCHMIDT

     ENDPROC DRIVE_ORTHO
#    -------------------

     PROC RESCALE_NEW_C
#    ------------------
     sip_barrier 

     SUMA = 0.0
     SUMB = 0.0
     TMPA = 0.0
     TMPB = 0.0
     PARDO i, a

            GET  R1a_intmd[a,i]
            Tai[a,i] = R1a_intmd[a,i]
            TMP   = Tai[a,i] * Tai[a,i]
            TMPA += TMP

      ENDPARDO i, a

      PARDO j, b

            GET  R1b_intmd[b,j]
            Tbj[b,j] =  R1b_intmd[b,j]
            TMP   = Tbj[b,j] * Tbj[b,j]
            TMPB += TMP

      ENDPARDO j, b

      sip_barrier 
      COLLECTIVE  SUMA += TMPA
      COLLECTIVE  SUMB += TMPB

      SUM_R  = SUMA
      SUM_R += SUMB

#bgn_debug
#     print SUM_R
#end_debug
 
      SQRT_OVERLAP = SUM_R ** (HALF)
      INV_SQRT_NORM_ORTGC  = SQRT_OVERLAP ** (MONE)

#bgn_debug
#     print INV_SQRT_NORM_ORTGC
#     print SQRT_OVERLAP
#end_debug
     
     PARDO a, i
          GET R1a_intmd[a,i]

          Tai[a,i]  = R1a_intmd[a,i]
          Tai[a,i] *= INV_SQRT_NORM_ORTGC

          PUT R1a[a,i] =  Tai[a,i]
     ENDPARDO a, i

     PARDO b, j
           GET R1b_intmd[b,j]

           Tbj[b,j]  = R1b_intmd[b,j]
           Tbj[b,j] *= INV_SQRT_NORM_ORTGC

           PUT R1b[b,j] =  Tbj[b,j]

     ENDPARDO b, j
     sip_barrier 

#bgn_debug
      tmpb=0.0
      tmpa=0.0
      suma=0.0
      sumb=0.0
      pardo i,a
         get r1a[a,i]
         Tmp =  r1a[a,i] *  r1a[a,i]
         tmpa += tmp
      endpardo i,a
      pardo j,b
         get r1b[b,j]
         tmp = r1b[b,j] * r1b[b,j]
         tmpb += tmp
      endpardo j,b
      sip_barrier
      collective suma +=tmpa
      collective sumb +=tmpb
      sip_barrier
      print suma
      print sumb
#end_debug


    ENDPROC RESCALE_NEW_C
#   ---------------------

     PROC SET_TO_ZERO
#    ----------------

     DO MINDEX50
           OVERLAP_R[MINDEX50] = 0.0
           A_DIAGS[MINDEX50]   = 0.0
     ENDDO MINDEX50

# This might get optimized! 
     PARDO NINDEX50, MINDEX50
           A_MATRIX[MINDEX50,NINDEX50]   = 0.0
           PUT ORTHO_COEF[MINDEX50,NINDEX50] = 0.0
     ENDPARDO NINDEX50, MINDEX50
#
     DO NINDEX50

        PARDO a, i
           PUT Y1a[a,i,NINDEX50] = 0.0
        ENDPARDO a, i

         PARDO b, j
           PUT Y1b[b,j,NINDEX50] = 0.0
         ENDPARDO b, j

     ENDDO NINDEX50

     PARDO a, i
           PUT R1a_intmd[a,i] = 0.0
     ENDPARDO a, i

     PARDO b, j
           PUT R1b_intmd[b,j] = 0.0
     ENDPARDO b, j
     sip_barrier 

     ENDPROC SET_TO_ZERO
#    -------------------

     PROC C_CHECK
#    -----------
     DO KINDEX50
        DO LINDEX50
           ETEMP[KINDEX50,LINDEX50] = 0.0
       ENDDO LINDEX50
     ENDDO KINDEX50

     NCOUNT = 0.0
     DO NINDEX50
        NCOUNT += 1.0
        IF NCOUNT > ITER_COUNT
           EXIT
        ENDIF

              MCOUNT = 0.0
              DO MINDEX50
                 MCOUNT += 1.0

                 IF MCOUNT > ITER_COUNT
                    EXIT
                 ENDIF

                    SUMA   = 0.0
                    SUMB   = 0.0
                    HC_A   = 0.0
                    HC_B   = 0.0

                     PARDO a, i

                            GET R1A_HIST[a,i,NINDEX50]
                            GET R1A_HIST[a,i,MINDEX50]

                            Tai[a,i ]  = R1A_HIST[a,i,NINDEX50]
                            T1ai[a,i]  = R1A_HIST[a,i,MINDEX50]

                            TMP   = Tai[a,i ] * T1ai[a,i]
                            SUMA += TMP

                     ENDPARDO a, i

                     PARDO b, j 

                           GET R1B_HIST[b,j,NINDEX50]
                           GET R1B_HIST[b,j,MINDEX50]

                           Tbj[b,j]  = R1B_HIST[b,j,NINDEX50]
                           T1bj[b,j] = R1B_HIST[b,j,MINDEX50]

                            TMP   = Tbj[b,j] * T1bj[b,j]
                            SUMB += TMP

                     ENDPARDO b, j 

                     SIP_BARRIER
                     COLLECTIVE HC_A += SUMA
                     COLLECTIVE HC_B += SUMB

                     A_VALUE  = HC_A
                     A_VALUE += HC_B

                     KCOUNT = 0.0
                     DO KINDEX50
                         KCOUNT += 1.0
                            LCOUNT = 0.0
                            DO LINDEX50
                               LCOUNT += 1.0
                                  ETEMP[MINDEX50,NINDEX50] = A_VALUE
                            ENDDO LINDEX50
                     ENDDO KINDEX50

              ENDDO MINDEX50
     ENDDO NINDEX50
#bgn_debug
     if rank==0.0
     execute a4_print_static etemp  iter_count iter_count 
     endif 
#end_debug

     ENDPROC C_CHECK
#    ---------------

#     BEGIN MAIN PROGRAM
#     -----------------

# Initilize the vaiable to zmax and imax (memory of ERD and OED).
      IMEM_max = 0.0
      ZMEM_max = 0.0
      execute compute_int_scratchmem oed_ovl ZMEM_max IMEM_max
      sip_barrier

# Restore the standard arrays.

     restore_persistent ca     "ca"
     restore_persistent cb     "cb"
     restore_persistent Fock_a "fock_a"
     restore_persistent Fock_b "fock_b"
#
# Some initialization of constants 
#
      TARGET_ROOTS  = (Scalar)eom_roots
      RPA_THRES     = EOM_TOL
#      MAX_SUBSP_DIM = (Scalar)EOM_SUBSPC
      MAX_SUBSP_DIM = 50.0

#bgn_debug
      execute get_my_rank rank 
      print eom_roots
      print eom_tol
      print max_subsp_dim
#end_debug
#
# Transformation can be done externally; in order to do that uncomment 
# READ_MO_INTS and comment TRAN_UHF. 
#
#      CALL READ_MO_INTS 

      CALL TRAN_UHF
      CALL FORM_DIAG
#
# The initial guess is moved to the loop that treat singlets and triplet.
# Since the triplets are simply genetrated by changing the beta block's
# element's sign one can generate the guess once for both singlets and
# tiplets, but some internal ACES III issues prevent me from doing that.
# It's so cheap it is adavantages to do it twice instead of storing. 
#

      MULT = 0.0
      ONE  = 1.0
      TWO  = 2.0
      ZERO = 0.0
      MONE = -1.0
      HALF = 0.5
      AA   = ONE
      BB   = TWO

      SINGLET = ZERO
      TRIPLET = ZERO 

      DO SPN_MULT 

         MULT  += 1.0

         IF MULT == ONE 
            SINGLET = ONE
            TRIPLET = ZERO
         ELSE 
            SINGLET = ZERO 
            TRIPLET = ONE 
         ENDIF 
#bgn_debug
         print mult
         print singlet 
         print triplet 
#end_debug

         CALL FORM_INITIAL_GUESS

         ROOT_COUNT = 0.0
         DO NROOTS

            ROOT_COUNT += 1.0
            IF ROOT_COUNT > TARGET_ROOTS
               EXIT
            ENDIF
#bgn_debug
        print ROOT_COUNT
#end_debug
            MYROOT = ROOT_COUNT
            CALL PREP_RPA_GUESS

            ITER_COUNT = 0.0
   
            DO SUBSP_DIM
   
               CALL SET_TO_ZERO
   
               ITER_COUNT += 1.0
#bgn_debug
         print ITER_COUNT
##end_debug
               IF ITER_COUNT > MAX_SUBSP_DIM
                   EXIT
                ENDIF

                CALL SAVE_C_VECTORS
#bgn_debug
#            call c_check
#end_debug
                CALL HC_MULT

                CALL SAVE_HC_VECTORS

                IF ITER_COUNT == 1.0
                   CALL FORM_A_MATRIX_11
                ELSE
                  CALL FORM_A_MATRIX_IJ
                  CALL FORM_A_MATRIX_JI
                  CALL FORM_A_MATRIX_II
                ENDIF
#bgn_debug
            if rank==0.0
            execute a4_print_static A_MATRIX ITER_COUNT ITER_COUNT
            endif 
#end_debug
              EXECUTE A4_XGEEV A_MATRIX DVECTORS DUMMY 
#bgn_debug
            if rank==0.0
            execute a4_print_static A_MATRIX ITER_COUNT ITER_COUNT
            endif 
#end_debug

               IF ITER_COUNT != 1.0
                  CALL REORDER_A_EIGS
               ENDIF
#
# The eigen vectors are normalized and ordered in descending order of the
# eigenvalues. The corresponding eigenvalues are in the diagonal.
#
               IF ITER_COUNT == 1.0
                  CALL FORM_NEWVECS_ITR1
               ELSE
    
                  CALL FORM_NEWVECS
    
                  CALL SELECT_VECS

                  CALL FORM_SELECTED_Y
    
                  CALL FORM_HBAR_Y_VECS
    
                  CALL FORM_RESIDUAL_VEC
    
                  CALL CHECK_CONVERGENCE
#bgn_debug
      print RESIDUAL_NORM
#end_debug
                  IF RESIDUAL_NORM  < RPA_THRES
                    EXIT
                  ENDIF
    
                  CALL FORM_CORRECTION_VEC
    
                  CALL DRIVE_ORTHO
    
                  CALL RESCALE_NEW_C
    
               ENDIF
    
             SIP_BARRIER
             ENDDO SUBSP_DIM
    
             SIP_BARRIER
#bgn_debug
      print OMEGA
#end_debug

             IF ITER_COUNT == MAX_SUBSP_DIM
                IF RESIDUAL_NORM  > RPA_THRES
#
# The root under consideration could not be locates in 50 cycles.
# Lets set energy to zero and inform the user whart that means
#
                    OMEGA = 0.0
                 ENDIF
             ENDIF
    
             IF SINGLET == ONE 
                MCOUNT = 0.0
                DO MROOTS
                   MCOUNT += 1.0
                   IF MCOUNT == ROOT_COUNT
                      RPA_S_EES[MROOTS] = OMEGA
                   ENDIF
                ENDDO MROOTS
             ENDIF 

             IF TRIPLET == ONE 
                MCOUNT = 0.0
                DO MROOTS
                   MCOUNT += 1.0
                   IF MCOUNT == ROOT_COUNT
                      RPA_T_EES[MROOTS] = OMEGA
                   ENDIF
                ENDDO MROOTS 
              ENDIF 

          ENDDO NROOTS

          SIP_BARRIER

#bgn_debug
      ROOT_COUNT -= 1.0
      IF SINGLET == ONE
         if rank==0.0
         execute a4_print_static RPA_S_EES ROOT_COUNT ONE
         endif 
         five_five = 55.0
#         execute print_rel_info five_five RPA_S_EES
      ENDIF 
      IF TRIPLET == ONE
         five_six = 56.0
         if rank==0.0
         execute a4_print_static RPA_T_EES ROOT_COUNT ONE
         endif 
#         execute print_rel_info five_six RPA_T_EES 
      ENDIF 
#end_debug

      ENDDO SPN_MULT

                       ENDSIAL HFSTABILITY_UHF
#                      -----------------------
